<HTML>
<HEAD>
<TITLE>Using the W3C Reference Library</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen,  9-Feb-1996 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using">

<H1>Using the W3C Reference Library</H1>

<IMG SRC="../../../Icons/WWW/construction.gif" ALT="WIP"> This paper is still under
construction. Comments are welcome at <A HREF="mailto:libwww@w3.org">libwww@w3.org</A></P>

This guide describes the "user's view" of the W3C Reference Library. It concentrates on describing
the API and how the application programmer can use the Library. It also describes who is responsible
for memory management, how to initialize modules etc. Reading this guide should be sufficient in
order to use the Library without being aware of exactly what is going on underneath the
interface. <P>

<IMG ALIGN=BOTTOM SRC="../../../Icons/32x32/caution.gif" ALT="NOTE"> This document is also available
as <A HREF="choppy.html"><B>one big HTML file</B></A> intended for printout. Please note that not
all links in this version work!<P>

<H2>Table of Contents</H2> 
<OL>
<LI><A HREF="Startup.html">Getting Started</A>
<LI><A HREF="Core.html">The Core</A>
<UL>
<LI><A HREF="Prefs.html">Request Preferences</A>
<LI><A HREF="Methods.html">Registering Access Schemes</A>
<LI><A HREF="Bind.html">Make Bindings to the local File system</A>
<LI><A HREF="MIME.html">Registering Protocol Headers</A>
<LI><A HREF="Net.html">Request Callback functions</A>
<LI><A HREF="Error.html">Errors Messages</A>
<LI><A HREF="Dialogs.html">User Dialogs and Progress Notifications</A><P>

<LI><A HREF="Streams.html">Stream Objects</A>
<LI><A HREF="Anchors.html">Anchor Objects</A>
<LI><A HREF="Request.html">Request Objects</A><P>

<LI><A HREF="Access.html">The Access Manager</A>
<LI><A HREF="Event.html">The Event Manager</A> <P>
</UL>

<LI><A HREF="Application.html">Application Modules</A>
<UL>
<LI><A HREF="Cache.html">The Cache Manager</A>
<LI><A HREF="Proxy.html">Registering Proxy Servers and Gateways</A>
<LI><A HREF="Rules.html">Rule File Management</A> and <A HREF="RuleSyntax.html">Rule File Syntax</A>
<LI><A HREF="Logging.html">The Log Module</A>
<LI><A HREF="History.html">The History Module</A>
<LI><A HREF="HTML.html">Presentation Modules</A><P>
</UL>

<LI><A HREF="Utils.html">Utility Modules</A>
<UL>
<LI><A HREF="Memory.html">Dynamic Memory Management</A>
<LI><A HREF="Flags.html">Trace Messages and Preprocessor Defines</A>
</UL>
</OL>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 


<HTML>
<HEAD>
<TITLE>Getting Started</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen,  7-Feb-1996 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Getting Started</H1>

This guide assumes that you have already compiled the library and are ready to use it building an
application. If this is not the case then please read the <A
HREF="../Installation.html">Installation guide</A> before you continue reading this document. One
thing to note is that as new versions of the Library are released frequently, it is recommended that
you verify that the version is up to date. On a Unix platform you can do this by typing the
following command

<PRE>
	cat Library/Implementation/Version.make
</PRE>

assuming that you are at the top of the WWW tree created when unpacking the distribution file. You
can compare your version of the code with the current version which is available from the online
documentation from our WWW server.<P>

The Library functionality is divided into a set of modules that each has its own include file. They
all have a name starting with <EM>WWW</EM>, and as they will be referenced throughout this guide, we
might as well introduce them from the beginning:

<DL>
<DT><A HREF="../../Implementation/WWWUtil.html">WWWUtil.h</A>
<DD>The WWW Utility module contains a lot of the functionality that makes it possible to make
applications, that is container modules for data objects, basic string functionality etc. This
module is the basis for all of the following modules and is used extensively.

<DT><A HREF="../../Implementation/WWWCore.html">WWWCore.h</A>
<DD>The WWW Core module is a set of registration modules that glues an application together. It
contains no real functionality in itself; it is for example not capable of loading a HTML
document. It only provides a large set of hooks which can be used to add functionality to the
Library and to give an application real life. We will here a lot more to the structure of the core,
and much of this guide is actually describing how to add functionality to the core.

<DT><A HREF="../../Implementation/WWWLib.html">WWWLib.h</A>

<DD>This include is the main include file for the Library. It basically consists of the <A
HREF="../../Implementation/WWWUtil.html">WWWUtil.h</A> and the <A
HREF="../../Implementation/WWWCore.html">WWWCore.h</A> so that the application only needs to include
this one instead of two.

<DT><A HREF="../../Implementation/WWWApp.html">WWWApp.h</A>
<DD>This module contains a huge set of modules that can be hooked into the Core Library and make the
application work. In contrast to the Core part, you can pick exactly the modules you want from the
<A HREF="../../Implementation/WWWApp.html">WWWApp.h</A> in order to create your special application
whether it is a server, a client, a proxy, a robot or any other Web application.

</DL>

As mentioned, in order to use the core public functions of the Library, your application needs to
include the file "<A HREF="../../Implementation/WWWLib.html">WWWLib.h</A>". This file is a container
for all the Library include files that together define the public API of the core of the Library. As
described in the document <A HREF="../Architecture/">Library Architecture</A> the core is a frame
work for other modules that provide the actual functionality, for example for parsing HTML documents
or getting a document via HTTP or FTP. We will explain later how this functionality can be enabled
and used by an application.<P>

The application must explicitly initialize the Library before it can start using it so that the
internal file descriptors, and variables can be set to their respective values. This only has to be
done once while the application is running and is typically done when the application is
started. The application also should close down the Library when it has stopped using it - typically
when the application is closing down. The Library will then return resources like file descriptors
and dynamic memory to the operating system. In practice the initialization and termination is done
using the following two functions:

<PRE>
BOOL HTLibInit(const char * AppName, const char * AppVersion)
</PRE>

This function initializes memory, file descriptors, and interrupt handlers etc. By default it
also calls initialization functions for all the dynamic modules in the Library. The dynamic modules
are described in "<A HREF="../Architecture/DesignModel.html">Libwww Architecture</A>". A major part
of the User's Guide is devoted to describing how the Library can be configured, both at run time and
at compile time, and the dynamic modules are an important part of the Library configuration. <P>

The two arguments to the function are the name of the application and the version number
respectively. It is not a requirement that these values are unique and they can both be the empty
string (""). However, as the strings are used in the <A HREF="../../Implementation/HTTP.html/">HTTP
protocol module</A> when communicating with other WWW applications it is strongly recommended that
the values are chosen carefully according to the <A HREF="../../../Protocols/">HTTP
specifications</A>. The most important requirement is to use normal ASCII characters without any
form for space as we will see in the example below.

<PRE>
BOOL HTLibTerminate()
</PRE>

This function cleans up the memory, closes open file descriptors, and returns all resources to
the operating system.

</DL>

It is essential that <CODE>HTLibInit(...)</CODE> is the first call to the Library and
<CODE>HTLibTerminate()</CODE> is the last as the behavior otherwise is undefined.

<H2>Building your first Application</H2>

We have now explained the first few steps in how to initialize the core of the Library. We can now
write our first minimal application which will do absolutely nothing but initializing and
terminating the Library. In the example we assume that the compiler knows where to look for the
Library include file <CODE>WWWLib.h</CODE> and also knows where to find the binary library, often
called <CODE>libwww.a</CODE> on Unix platforms and <CODE>libwww.lib</CODE> on Windows. Again, the
result might depend on the setup of the dynamic modules, but if no dynamic modules are enabled then
the example will generate an executable file. If you are in doubt about how to set your compiler
then you can often get some good ideas by looking into the <A HREF="../../../LineMode/">Line Mode
Browser</A>. <P>

PS: You can find the examples directly in form of C files in our <A
HREF="../../Examples/">example area</A>

<PRE>
#include "WWWLib.h"
int main()
{
    HTLibInit("TestApp", "1.0");
    HTLibTerminate();
    return 0;
}
</PRE>

Some platforms require a socket library when building network applications. This is for example the
case when building on Macintosh or Windows machines. The Library uses the <A
HREF="http://err.ethz.ch/members/neeri/macintosh/gusiman/GUSI.html">GUSI socket</A> library on the
Macintosh and the <A HREF="ftp://ftp.spry.com/ms-windows/winsock/docs/winsock.txt">WinSock
library</A> on windows platforms. Please check the documentation on these libraries for how to
install them and also if there are any specific requirements on your platform when building network
applications.<P>

<H2>Adding Functionality</H2>

The core parts of the Library can be thought of as a framework with hooks for adding functionality
depending on what the applications needs. The core can not do anything on its own but when hooking
in modules, the Library suddenly can start doing useful stuff. In the Library distribution file
there is already a large set of specific protocol modules and stream modules for handling many
common Internet protocols and data formats. We will explain protocol modules and streams in much
more detail later, but for the moment it is sufficient to know that protocol modules knows how to
communicate with remote servers on the Internet and that streams are used to pass documents back and
forth between the Internet and the application with the Library as an intermediary part. <P>

While the previous application wasn't capable of doing anything we will now add functionality so
that we can request a URL from a remote Web server and save the result to a file. To do this we need
to register two additional modules after initializing the Library: A protocol module that handles
HTTP and a stream that can save data to a local file. Both these modules are already in the
distribution file and in this example we show how to enable them. It is also possible to write your
own versions of these modules and then register them instead of the ones provided with the
Library. This makes no difference to the core part of the Library and is an example of how the
functionality can be extended or changed by adding new modules as needed. <P>

<PRE>
#include "WWWLib.h"
#include "HTTP.h"

int main()
{
    HTList *converters = HTList_new();		     /* Create a list object */

    /* Initialize the Library */
    HTLibInit("TestApp", "1.0");

    /* Register the HTTP Module */
    HTProtocol_add("http", YES, HTLoadHTTP, NULL);

    /* Add a conversion to our empty list */
    HTConversion_add(converters, "*/*", "www/present", HTSaveLocally, 1.0, 0.0, 0.0);

    /* Register our list with one conversion */
    HTFormat_setConversion(converters);

    /* Delete the list with one conversion */
    HTConversion_deleteAll(converters);

    /* Terminate the Library */
    HTLibTerminate();
    return 0;
}
</PRE>

The two new things in this example is that we now have two registration functions. We will explain
more about these functions as we go along; for now we will only introduce the functions and their
arguments. The interesting part about the two registration functions is that they represent the two
ways of registration in the Library: Some things are registered directly like the protocol module
and other things are registered as lists of objects like the list of converters. The reason for this
is to make the registration process easier for the application to handle; protocol modules are often
initialized only once while the application is running. Therefore it is easier to register them
directly. As we will see later in this guide, converters, however, can be enabled and disabled
depending on a regular basis depending on what the application is trying to do. It is therefore
easier to keep the converters in lists so that they can be enabled and disabled in batch. <P>

Now, let's take a closer look at the two registration functions. The first registers the HTTP
protocol module which enables the Library of accessing documents using HTTP from any server on the
Internet.

<PRE>
extern BOOL HTProtocol_add (const char *       	name,
			    BOOL		preemptive,
			    HTEventCallBack *	callback);
</PRE>

The first argument is a name equivalent to the scheme part in a URL, for example
<B>http</B>://www.w3.org, where <B>http</B> is the scheme part. When a request is issued to the
Library using a URL, it looks at the URL scheme and sees if it knows how to handle it. If not then
an error is issued. The second argument describes whether the protocol module supports non-blocking
sockets or not. This is a decision to be made when the module is first designed and can normally not
be changed. In the example we register HTTP for using blocking sockets, but all native Library
protocol modules including HTTP, FTP, News, Gopher, and access to the local file system supports
non-blocking sockets. The third argument is the name of the protocol function to be called when the
Library is about to hand off the request to the module.<P>

<PRE>
extern void HTConversion_add   (HTList *	conversions,
				CONST char * 	rep_in,
				CONST char * 	rep_out,
				HTConverter *	converter,
				double		quality,
				double		secs, 
				double		secs_per_byte);
</PRE>

This function has many arguments and we will not go into details at this point. The important thing
to note is that we build a list of converters. Each call to the <CODE>HTConversion_add</CODE>
creates a new converter object and adds it to the list. A converter object is described by an input
format (<CODE>rep_in</CODE>), an output format (<CODE>rep_out</CODE>), the function name of the
converter, and a quality factor describing how good the conversion is. The last two arguments are
currently not used but are reserved for future use. The quality factor later where we will see how
it can be used to distinguish between multiple conversions in order to pick the best one. <P>

Even though we now have initialized a protocol module and a converter, the program example is still
not actively doing anything. It only starts the Library, registers two modules and then terminates
the Library again. Our third and last example in this section does the same amount of initialization
but does also issue a request to the Library for fetching a URL.

<H2>Fetching a URL</H2>

We now want to create an example which is capable of issuing a request to the Library to fetch a
URL. When doing this we must create a request object that contains all information that is
necessary in order to handle the request. Then we pass this object to the Library and if the
request is valid and the document does exist we get the data back. In the example we read the URL to
fetch from the command line. As in the other examples we are not too worried about error checking
and error messaging. In a real application you must of course do this, but here we want to keep the
examples simple.

<PRE>
#include "WWWLib.h"
#include "HTTP.h"
#include "HTDialog.h"

int main (int argc, char ** argv)
{
    HTList * converters = HTList_new();
    HTRequest * request = HTRequest_new();	  /* Create a request object */
    WWWTRACE = SHOW_ALL_TRACE;
    HTLibInit("TestApp", "1.0");
    HTProtocol_add("http", YES, HTLoadHTTP, NULL);
    HTConversion_add(converters, "*/*", "www/present", HTSaveLocally, 1.0, 0.0, 0.0);
    HTFormat_setConversion(converters);
    HTAlert_add(HTPrompt, HT_A_PROMPT);
    if (argc == 2) {
	HTLoadAbsolute(argv[1], request);
    } else
	printf("Type the URL to fetch\n");
    HTRequest_delete(request);			/* Delete the request object */
    HTConversion_deleteAll(converters);
    HTLibTerminate();
    return 0;
}
</PRE>

When this program is run, it will take the argument and call the Library to fetch it. As we haven't
given any name for the file which we are creating on our local disk, the Library will prompt the
user for a file name. Automatic redirection and access authentication is handled by the HTTP module
but might require the user to type in a user name and a password. An example on how to run this
program is:

<PRE>
./fetch_url http://www.w3.org/pub/WWW/
</PRE>

The results stored in the file contains the whole message returned by the remote HTTP server except
for the status line. This means that if we ask a HTTP/1.0 compliant server then we receive a header
and a body where the header contains metainformation about the object, for example content type,
content language etc. We shall later see how the MIME parser stream can strip out the header
information so that we end up with the body of the response message. <P>

In the next chapters we shall see that protocol modules and converters only is a part of what can be
registered in the Library and that the application can specify many other types of preferences and
capabilities.

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>User Guide - The Library Core</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 20-Nov-1995 -->
<NEXTID N="z78">
</HEAD>
<BODY>

<A HREF="../../../"><IMG ALT="W3C" SRC="../../../Icons/WWW/w3c_48x48.gif"></A>
<A HREF="../../"><IMG ALT="Lib" SRC="../../../Icons/WWW/Lib48x.gif"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>The Library Core</H1>

As mentioned earlier in this guide, the Core of the W3C Reference Library is the set of modules that
must be included in every application. However, the core does not contain any functionality for
neither requesting a HTML document using HTTP, not to parse it or present it to the user. All this
functionality is dynamically registered in the core using an open set of application modules which
we will describe later. <P>

The Core is basically a set of registration mechanisms that glue together the application modules,
and in the following chapter we will look how to configure the core to contain exactly the
functionality we want for our application. If you are interested in a more detailed description of
the architecture of the core to see how the glue is designed then please read the <A
HREF="../Architecture/ControlFlow.html">chapter on the model behind the Core of the Library</A> in
the Architecture document. In this section we will concentrate on the APIs defined by the <A
HREF="../../Implementation/WWWCore.html">WWWCore.h</A> include file and how to use the Core in a
real application.

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML>
<HTML>
<HEAD>
<TITLE>User's Guide - Preferences</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 29-Jan-1996 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Request Preferences</H1>

The introductory chapter introduced converters and how they can be set up. Converters are a part or
a family of preferences in the Library that can be configured by applications and this chapter
explains in more detail how to use these features. The family of preferences includes the following
members:

<UL>
<LI>Format converters
<LI>Natural languages
<LI>Content encodings
<LI>Character sets
</UL>

As mentioned in the previous chapter, when the Library is first initialized, it knows nothing about
these preferences. By specifying preferences, the application can tailor the Library to fit the
features supported by the application and by the end user. In the following section we will describe
how the application can set up the various preferences. All preferences described in this chapter
use lists to group the sets together. As we will see later in this chapter, the reason for this is
that lists are an easy way of assigning specific preferences to various requests. <P>

<A NAME="converters"><H2>Format Converters</H2></A>

We have already seen an example on how a converter can be set up. Let's take a step back and look at
the declaration of the function that adds a converter, <CODE>HTConversion_add(...)</CODE>:

<PRE>
extern void HTConversion_add   (HTList *	conversions,
				CONST char * 	rep_in,
				CONST char * 	rep_out,
				HTConverter *	converter,
				double		quality,
				double		secs, 
				double		secs_per_byte);
</PRE>

The first argument is a <A HREF="../../Implementation/HTList.html">list object</A>. List objects are
one of the several container objects in the Library and they are explained in more details in the <A
HREF="../Guide/">W3C Library Internals</A>. All we have to know at this point is to create a list
object:

<PRE>
extern HTList *	HTList_new (void);
</PRE>

The two next arguments describes the input format and the output format of the data that is entering
and leaving the converter respectively. The syntax for these formats follow the syntax defined by
the <A HREF="../../../Protocols/">HTTP Protocol</A> and the <A
HREF="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1521.txt">MIME specification</A> which
has a <EM>type</EM> string and a <EM>subtype</EM> string separated by a slash "/"

<PRE>
	&lt;type&gt; "/" &lt;subtype&gt;
</PRE>

Some of the most common examples are

<PRE>
	text/plain
	text/html
	image/gif
	audio/basic
	*/*
</PRE>

In addition to these "official" MIME types, the Library has a small set of internal representations
that uniquely exist within the Library. They are used to describe data formats that are not really
formats but an intermediate state of the document. The two most used formats of this type are

<PRE>
	www/present
	www/unknown
</PRE>

The internal formats are characterized by having the type <EM>www</EM> which doesn't exist anywhere
but in the Library. The first of the two subtypes shown represent the rendered document as presented
to the user and the second subtype represents an unknown data format. <P>

The <CODE>converter</CODE> argument is a pointer to the function that is to be called in order to
create a converter object capable of handling the conversion from the input type to the output
type. By registering a pointer pointing to the converter, the converter can be set up dynamically.
This allows the Library to evaluate the set of registered converters each time a conversion is
requested and then chose the best suitable converter on the fly. <P>

The next argument is the <EM>quality factor</EM> which we will describe in a separate paragraph
later in this chapter. The last two arguments are not currently used but are reserved for future
use. For now, using a value of 0 is perfectly valid. <P>

Converters are intended to be used when we have our own module to handle the data coming from the
remote server. The module can either be one provided by the Library or one made by the
application. However, in some cases we would rather hand off the data to an external application for
presenting the data. Often external applications are viewers of some sort, for example a postscript
viewer or a mpeg viewer. The Library lets us register external applications as <EM>presenters</EM>
very much like converters. This will become obvious if we take a look at how we register presenters:

<PRE>
extern void HTPresentation_add (HTList *	conversions,
				CONST char * 	representation,
				CONST char * 	command,
				CONST char * 	test_command,
				double		quality,
				double		secs, 
				double		secs_per_byte);
</PRE>

As was the case with converters, the first argument is a list which we create in exactly the same
way as shown before. Presenters only need a input format as we hand off the data to the external
application and never sees it again. A special thing about presenters and converters is that as they
are very similar they are also treated very much alike internally in the Library. Therefore a list
object can contain both converters and presenters at the same time. This makes often the management
easier for the application instead of having to deal with two separate lists.<P>

The next field is reserved to be used in connection with mail cap parsers as the <EM>test field</EM>
of a mail cap file. The Library does not yet directly support <A
HREF="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1524.txt">Mail Cap files</A> but the
registration of presenters is foreseen to be able to work with mail cap files. The <A
HREF="../../../Arena/">Arena browser</A> is an example of an application having its own Mail Cap
file parser while using the Library. The description of the test field in <A
HREF="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1524.txt">RFC 1524</A> is included
below: <P>

<EM>The "test" field may be used to test some external condition (e.g., the machine architecture, or
the window system in use) to determine whether or not the mail cap line applies. It specifies a
program to be run to test some condition. The semantics of execution and of the value returned by
the test program are operating system dependent, with UNIX semantics specified in Appendix A. If the
test fails, a subsequent mail cap entry should be sought. Multiple test fields are not permitted --
since a test can call a program, it can already be arbitrarily complex.  </EM> <P>

The last three arguments are exactly identical to the conversion registration so there is no need to
describe them any more here. Again, the quality factor will be described in details later in this
chapter.<P>

<H2>Natural Languages</H2>

The preferred natural language or languages is in almost all situations dependent on the individual
user and an application should therefore give the user the opportunity to change the setup. When
specifying a natural language preference, the Library will send this preference along with all HTTP
requests. The remote server will then (it if supports this feature) look for a version in the
language or languages mentioned. If it finds a matching document then it returns this one, otherwise
it uses the best alternative. If no language is specified the remote server may whatever version it
finds. You can add an element to the list of natural languages by using the following function:

<PRE>
extern void HTLanguage_add (HTList *		list,
			    CONST char *	lang,
			    double		quality);
</PRE>

The list object containing the set of natural languages is similar to the list elements containing
the converters and the presenters. However, in contrast to the former two which actually can be one
list, the list of natural languages must be a list on its own. <P>

The semantics of the language argument follows closely the <EM>Language</EM> tag of the <A
HREF="../../../Protocols/">HTTP protocol</A> which in terms is based on the <A
HREF="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1766.txt">RFC 1766</A>. Some example
tags are

<PRE>
	en
	en-US
	en-cockney
	i-cherokee
	x-pig-latin
</PRE>

where any two-letter primary tag is n <A HREF="http://www.iso.ch">ISO</A> 639 language abbreviation
and any two-letter initial subtag in an ISO 3166 country code.

<H2>Content Encodings</H2>

Some documents are not send in their original data obejct but is encoded in some way. On the Web
this is mostly some kind of compression but other encodings for example base 64 can be encountered
when talking to NNTP servers etc. Just as for the other preferences, an application can register a
supported encoders or decodes as a list. Encoders and decoders are registered in the same way with
no differentiation whether it is a encoder or a decoder:

<PRE>
extern void HTEncoding_add (HTList * 		list,
			    CONST char *	encoding,
			    double		quality);
</PRE>

The list argument is the now well-known way of handling these preferences and we will see this many
more times throughout the guide. The "encoding" argument is a constant string just like the data
format descriptions in the registration of converters and presenters. The values are also inspired
strongly by the <A HREF="../../../Protocols/">HTTP Protocol</A> and the <A
HREF="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1521.txt">MIME specification</A> and
some of the most common examples are:

<PRE>
	base64
	compress
	gzip
</PRE>

As the list of natural languages, the list of encoders and decoder must be a separate list.

<H2>Character Sets</H2>

As the Web reaches all parts of the Internet there are more and more documents written in languages
which contains characters not included in the ISO-8859-1 character set. A consequence of this the
set of characters sets is often tightly connected with the natural language. The Library does not
directly support other character sets but in case an application is capable of handling alternative
sets it can register these as preferred character sets along with a quality factor just as all the
other preferences in this section.

<PRE>
extern void HTCharset_add (HTList *		list,
			   CONST char *		charset,
			   double		quality);
</PRE>

Also the <EM>charset</EM> argument is inspired by the <A HREF="../../../Protocols/">HTTP
Protocol</A> and the <A HREF="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1521.txt">MIME
specification</A>. Some of the most common examples of the charset parameter is:

<PRE>
	US-ASCII
	ISO-8859-1
	UNICODE-1-1
</PRE>

Again, the list of preferred character sets must be a separate list.

<H2>The Quality Factor</H2>

Characteristic for all the preferences above is that there is a quality factor associated with each
member. The quality factor is a real number between 0 and 1 with 0 meaning "very bad" and 1 means
"perfect". By registering a natural language or any or other preference in this group together with
a quality factor you can specify "how well the preference is handled" either by the application or
by the user. In the case of the user the quality factor of a natural language is how well the user
understands the language. In my case, the quality factors for, for example Greek would be close to
zero and 1 for Danish (nothing bad said about Greek!). <P>

It is a bit different for converters where it is often the application's ability of handling the
data format rather than the user's perception. As an example it is often faster to use a converter
than a presenter as it takes time to launch the external application and the Library can not use
progressive display mechanisms which is often the case for converters. Therefore, as an example, if
we capable of handling an image in <EM>png</EM> format inline but rely on an external viewer for
presenting postscript, we might set up the following list:

<PRE>
HTConversion_add (converters, "image/gif", "www/present", GifPresenter, <B>1.0</B>, 0.0, 0.0);

HTPresentation_add (presenters, "application/postscript", "ghostview %s", NULL, <B>0.5</B>, 0.0, 0.0);
</PRE>

where the gif converter is registered with a quality factor of <B>1.0</B> and the postscript
presenter with a quality factor of <B>0.5</B>.

<H2>Enabling Preferences</H2>

All we have done until now is to show how we can register sets of preferences. However, we still
need to define where and when to actually let the Library use the preferences. This can be done in
two ways: Globally or locally. When assigning a set of preferences, for example the set of natural
languages, it can either be assigned to <EM>all</EM> future requests (globally) or to a specific
request (locally). The preferences can also partly be assigned globally and partly locally so that
the most common preferences are registered globally and only some preferences specific to a single
request is then added by registering the sets locally. <P>

Here we will only show how to enable the preferences globally. Later when we have discussed how to
create a request object we will see how to enable the preferences locally and also if they are to
be added to the global list or completely override the global list for a particular request.

<H3>Converters and Presenters</H3>

<PRE>
extern void HTFormat_setConversion	(HTList *list);
extern HTList * HTFormat_conversion	(void);
</PRE>

<H3>Content Encodings</H3>

<PRE>
extern void HTFormat_setEncoding	(HTList *list);
extern HTList * HTFormat_encoding	(void);
</PRE>

<H3>Content Encodings</H3>

<PRE>
extern void HTFormat_setLanguage	(HTList *list);
extern HTList * HTFormat_language	(void);
</PRE>

<H3>Character Sets</H3>

<PRE>
extern void HTFormat_setCharset		(HTList *list);
extern HTList * HTFormat_charset	(void);
</PRE>

<H2>Cleaning up Preferences</H2>

As the application is responsible for setting up the sets of preferences, it is also responsible for
deleting them once they are not needed anymore, for example when the application i s closing down,
or the user has changed them. The Library provides two mechanisms for cleaning up old lists: It can
either be done by invoking separate methods on each set of preferences, or it can be done in a batch
of all globally registered preferences or all locally registered preferences relative to a single
request. In this context, a batch is the total set of registered converters, encoder, charsets, and
languages. Here we will only show how to cleanup preferences set-wise and as a globally batch of
preferences. We leave the local cleanup until we have described the request object later in this
guide. <P>

Common for the cleanup methods is that when they have been called you can nor more use the lists as
they are not pointing to valid places in the memory. The first mechanism for cleaning up lists is by
calling the cleanup method of each preference as indicated below:

<H3>Converters</H3>

<PRE>
extern void HTConversion_deleteAll	(HTList * list);
</PRE>

<H3>Presenters</H3>

<PRE>
extern void HTPresentation_deleteAll	(HTList * list);
</PRE>

<H3>Content Encodings</H3>

<PRE>
extern void HTEncoding_deleteAll	(HTList * list);
</PRE>

<H3>Content Languages</H3>

<PRE>
extern void HTLanguage_deleteAll	(HTList * list);
</PRE>

<H3>Character Sets</H3>

<PRE>
extern void HTCharset_deleteAll		(HTList * list);
</PRE>

The second mechanism which at once cleans up all globally registered preferences can often be used
in order to simplify the management done by the application. Note, however, that all globally lists
become inaccessible for future reference. In you want to define new sets of preferences then you
need to start all over again and create a new list object.

<PRE>
extern void HTFormat_deleteAll		(void);
</PRE>

<H2>Getting Help on Initialization Converters and Presenters</H2>

The Library has a special module called <A HREF="../../Implementation/HTInit.html">HTInit</A> which
helps the application doing the initialization of all the converters and other preferences supported
internally by the Library. This module is not called directly from the Library and must explicitly
be invoked by the application. <A HREF="../../Implementation/HTInit.html">HTInit</A> is a part of
the <A HREF="../../Implementation/WWWApp.html">WWWApp.h</A> include file described in the previous
section, so if you include this in your application then you have direct access to the following
functions:

The following function initializes all the converters supported natively by modules in the Library
distribution file:

<PRE>
extern void HTConverterInit	(HTList * conversions);
</PRE>

There is a similar function for registering a common set of presenters that can be found on many
(especially Unix) platforms:

<PRE>
extern void HTPresenterInit	(HTList * conversions);
</PRE>

In order to show the similarity between how converters and presenters are handled in the Library,
there is also a single function that does the work of the two previous functions at once:

<PRE>
extern void HTFormatInit	(HTList * conversions);
</PRE>

<H2>Summary</H2>

We have now seen how to enable multiple sets of preferences using a very similar naming scheme and
registration process. As mentioned in the beginning, lists are easy to handle when the preferences
are likely to be changed often as the application is executed. In the next section, we will take a
look at a slightly different registration mechanism which is more suited for topics that only rarely
are registered multiple times during the execution of an application.

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>Using - Access Modules</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 17-Jan-1996 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1><A NAME="methods">Enabling Access Modules</A></H1>

The Library comes with a wide set of access modules that gives access to most popular Internet
protocols including HTTP, FTP, Gopher, telnet, rlogin, NNTP and WAIS. However, as mentioned in the
beginning, when the Library is first initialized it knows nothing about how to access the
Internet. In fact it doesn't even know how to access the local file system. It is for the
application to tell the Library what it can handle and where to go find the functionality. This is
very much the same mechanism as we saw described in the previous chapter, so a lot of what is going
on will hopefully become clear as we go along.<P>

All protocol modules are dynamically bound to an access scheme. Take for example the following URL:

<PRE>
	<B>http</B>://www.w3.org/
</PRE>

It has the access scheme <B>http</B> and if we have a protocol module capable of handling HTTP then
we can make the binding between <B>http</B> and this module. As mentioned in the introduction to
this chapter, the Library already comes with a large set of protocol module, including HTTP so all
we have to do in this case is to register the HTTP module to the Library as being capable of
handling <B>http</B> URLs. <P>

Let's see how we can register a protocol module. The support for this is provided by the <A
HREF="../../Implementation/HTProt.html">protocol manager</A> which exports the following function:

<PRE>
extern BOOL HTProtocol_add (CONST char *       	scheme,
			    BOOL		preemptive,
			    HTEventCallBack *	callback);
</PRE>

This function follows exactly the same naming scheme as we have seen many times before. The first
argument the access scheme which the protocol module is capable of handling. This can for example be
<B>http</B>, but it can also be non-existent schemes which can be used for experimental protocol
implementations, for example <B>whois</B> etc. In case a protocol module is capable of handling more
than one access scheme, it can be registered multiple time with different schemes. This is the case
with the <A HREF="../../Implementation/HTTelnet.html">Telnet access module</A> which also can handle
<B>rlogin</B> and <B>tn3270</B> terminal sessions. <P>

<A NAME="preemptive"></A>The <CODE>preemptive</CODE> argument describes to the Library whether it is
capable of handling non-blocking sockets or not. This is normally a design decision when
implementing the protocol module in that a module implemented for using blocking sockets normally
can't use non-blocking sockets. However, the other way is often possible, and in some situations it
is advantageous to use blocking sockets. The Library allows this to happen on a pr request basic as
explained in the section <A HREF="Request.html#preemptive">"The Request Object"</A>. The <A
HREF="../Architecture/">Library Architecture</A> document discusses in more detail how a protocol
module can be designed to support non-blocking sockets. <P>

The last argument is the actual function name to call when a request has been issued and a protocol
module has been found associated with the access scheme used. Even though it is not clear at this
point the <CODE>HTEventCallBack</CODE> type is a function that the event handler uses in order to
initiate requests in the Library. <P>

A protocol module can be disabled at any time during execution. In most cases this is not uses very
often but the dynamic nature of the binding leaves this choice free to the application. In case it
is desired, you can do so by calling the following function:

<PRE>
extern BOOL HTProtocol_delete (CONST char * scheme);
</PRE>

The argument is exactly the same scheme as described above.

One special case is the support for access to <A HREF="../../../../Products/WAIS/">WAIS</A>
databases. WAIS has its own code Library called <A HREF="http://www.cnidr.org/" >freeWAIS</A> which
is required in order to directly access wais URLs. We shall not describe in describe in detail here
how this can be enabled as it is described in the <A HREF="../../../Gateways/WAISGate.html">the
WWW-WAIS gateway</A>.

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>Bindings to the local File system</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen,  5-Nov-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Bindings to the local File system</H1>

The preferences that we described in section <A HREF="Prefs.html">Request Preferences</A> did not
mention what the Library should do if it doesn't know the data format of a document. In many
protocols this information is provided by the remote server. Typical examples are MIME like
protocols where the metainformation such as the <EM>Content-Type</EM> and the
<EM>Content-Language</EM> is provided together with the document. However, applications often have
access to the local file system using <B>file</B> URLs which in general do not keep any or at least
very little information of the file type. It is therefore required to have some kind of binding
between the file system and the preferences registered in the Library which provides this
mateinformation about the object. <P>

Often files in a file system is classified by some sort of a suffix, for example GIF files are often
ending in <EM>.gif</EM>, text files in <EM>.txt</EM> etc. This binding is not static and it is
therefore required to have a dynamic binding just like the preferences themselves. An example of the
latter is HTML files which on most Unix systems end in <EM>.html</EM> whereas they on many MS-DOS
based systems end in <EM>.htm</EM>. <P>

The <A HREF="../../Implementation/HTBind.html">HTBind module</A> provides a generic binding
mechanism between a file and its representation internally in the Library. It is not limited to
simple file suffix classification but can also be used in more advanced environments using data
bases etc. However, at this point we are interested in how we can register bindings between file
suffixes and for example content types, content languages etc. <P>

Before starting a more detailed description of how to register file suffixes, it might be required
to define what actually is a file suffix and what is the set of delimiters separating them on a
particular platform. The Bind manager is born with a certain knowledge about the set of delimiters
but more can be added to provide the functionality desired. This can be done using the following
function:

<PRE>
extern void HTBind_caseSensitive	(BOOL sensitive);
</PRE>

where <EM>sensitive</EM> can either be <EM>YES</EM> or <EM>NO</EM>. Also the set of delimiters can
be defined using the following function:

<PRE>
extern CONST char *HTBind_delimiters	(void);
extern void HTBind_setDelimiters	(CONST char * new_suffixes);
</PRE>

Examples of a list of suffixes are

<PRE>
	"._"
	"."
	"._-"
</PRE>

Note that the suffixes chosen do not have to be connected with what is available on a particular
platform. However, a certain coupling will probably make maintenance of the file system easier for
all parties. In the following we will show the API for adding bindings between the preferences and
the file system. You can add a binding between a Content type and a suffix by using the following
function:

<PRE>
extern BOOL HTBind_addType	(CONST char *	suffix,
				 CONST char *	format,
				 double		value);
</PRE>

Calling this with <EM>suffix</EM> set to "*" will set the default representation which is used in
case no other suffix fits the actual file. Using a suffix set to "*.*" will set the default
representation for unknown suffix files which contain a "."  The <EM>format</EM> argument is exactly
like described in the section <A HREF="Prefs.html">Request Preferences</A>. In exactly the same way
you can add a binding between an encoding anda file suffix using the following function:

<PRE>
extern BOOL HTBind_addEncoding	(CONST char *	suffix,
				 CONST char *	encoding,
				 double		value);
</PRE>

Bindings can also be made between a file suffix and a specific natural language:

<PRE>
extern BOOL HTBind_addLanguage	(CONST char *	suffix,
				 CONST char *	language,
				 double		value);
</PRE>

In all cases, it should be mentioned, that any of the suffixes <EM>can</EM> contain characters that
normally must be escaped in a URL, for example space &lt; &gt;. However, they should <EM>not</EM> be
encoded when parsed as the <CODE>suffix</CODE> parameter but left as is.

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>Registering Protocol Headers</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen,  5-Nov-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Registering Protocol Headers</H1>

The Library provides a few powerful mechanisms to handle document metainformation and how to
generate and parse additional header information coming across the network. This section describes
how to handle metainformation and headers and how this can be used to experiment with existing
protocols by means of additional headers.

<H2>Header Generation</H2>

Outgoing metainformation describing preferences in requests or entities to be sent to a remote
server is handled in two ways: The Library supports a "native" set (called <EM>known</EM> headers of
headers which can be manipulated directly, but it also provides support for header extensions
defined by the application. This section describes how both the existing set of headers and the
extensions can be handled.

<H3>Generating Known Headers</H3>

The Library manages a "native" set of protocol headers which we will introduce in this section. The
default behavior for the Library is to use a representative set of headers on each request but all
headers can be explicitly enabled or disabled on a per request basic by the application. Here we
will mainly describe the set of native headers but leave the description of how to manipulate them
for the section on managing <A HREF="Request.html">Request objects</A>. The native set of headers
fall into the following three categories:

<DL>

<DT>General Headers

<DD>There are a few header fields which have general applicability for both request and response
messages, but which do not apply to the communication parties or the entity being transferred. This
mask enables and disables these headers. If the bit is not turned on they are not sent. All headers
are optional and the default value is not to use any of these headers at all.

<DT>Request Headers

<DD>The request header fields allow the client to pass additional information about the request (and
about the client itself) to the server. All headers are optional but the default behavior is to use
all request headers <EM>except</EM> <CODE>From</CODE> and <CODE>Pragma</CODE>. The reason is that
the former in general requires permission by the user and the latter has special meanings for proxy
servers.

<DT>Entity Headers

<DD>The entity headers contain information about the object sent in the HTTP transaction. See the <A
HREF="../../Implementation/HTAnchor.html">anchor module</A>, for the storage of entity headers. This
flag defines which headers are to be sent in a request together with an entity body. All headers are
optional but the default value is to use as many as possible.

</DL>

As mentioned, the set of native headers are equivalent to the set of header defined by the <A
HREF="../../../Protocols/">HTTP/1.1 protocol</A> specification. The Library also provides
functionality for registering additional headers which we will have a look at in the next section.

<H3>Generating Additional Headers</H3>

The API for handling extra headers is provided by the <A HREF="../../Implementation/HTHeader.html">
Header Manager</A>. The API is built in exactly the same way as we have seen in section <A
HREF="Request Preferences">Prefs.html</A>, that is it uses lists of objects as the main
component. This time the elements registered is callback functions which the application provides
the definition of. Each time a request is to be generated, the Library looks to see if a list of
callback functions has been registered to provide additional metainformation to send along with the
request. If this is the case then each of these callback functions will be called in turn and the
resulting request is then the sum of the original response and the information provided by the
callback functions. <P>

It should be mentioned, however, that this API is simple to use if you have a relative small amount
of extra metainformation to provide and that it easily fits into an existing protocol. It is not
suited for building entire new protocols, or to provide a massive amount of new information. In this
case you need a more powerful model which the Library also provides: building your own
stream. Actually this is exactly the way the the Library implements large parts of itself, but it
requires normally a bit more work before you can get an application pout together. <P>

Let us jump right in to it and have a closer look at the API. Exactly as for the request preferences
you can <EM>add</EM> and <EM>delete</EM> an element, which in this case is a callback function. This
function has a special definition which is given by

<PRE>
typedef int HTPostCallback (HTRequest *request, HTStream * target);
</PRE>

We have already seen the <EM>Request</EM> object before, but the <EM>Stream</EM> object is new. Or
actually it isn't, it has just not been mentioned explicitly in the previous sections. We will hear
a lot more about the stream object later in this guide. For now it is sufficient to know that a
stream i an object that accepts streams of characters - much like an ANSI file stream object
does. The return value of the callback function is currently not used but is reserved for future
use. We can register a callback function of type <EM>HTPostCallback</EM> by using the following
function:

<PRE>
extern BOOL HTGenerator_add (HTList * gens, HTPostCallback * callback);
</PRE>

The first argument is the well-known list object and the second is the address of the function that
we want to be called each time a request is generated. When the callback function is called by the
Library it must generate its metainformation and send it down the stream which eventually will end
up on the network as part of the final request. In exactly the same way you can unregister a
callback function at any time by calling the following function:

<PRE>
extern BOOL HTGenerator_delete (HTList * gens, HTPostCallback * callback);
</PRE>

<H2>Header Parsing</H2>

The <A HREF="../../Implementation/HTMIME.html">MIME parser stream</A> parses MIME metainformation,
for example generated by MIME-like protocols, such as HTTP, NNTP, and soon SMTP as well. For <A
HREF="../../../Protocols/">HTTP</A> it handles all headers as defined in HTTP/1.1 of the
specification. When a MIME header is parsed, the obtained metainformation about the document is
stored in the <A HREF="Anchors.html">anchor object</A> where it can be accessed by the application
using the methods of the <A HREF="../../Implementation/HTAnchor.html">Anchor module</A>. The
metainformation in an anchor object can also be used to describe a data object that is to be
<EM>sent</EM> to a remote location, for example using HTTP or NNTP, but we will describe this in
more detail later in this guide. In this case the order is reversed as the application provides the
metainformation and the appropriate headers are generated instead of generating the entries in the
anchor object by parsing the headers. <P>

<H3>Parsing Known Headers</H3>

The set of headers directly handled by the <A HREF="../../Implementation/HTMIME.html">internal MIME
parser</A> is the reader is referred to the actual implementation in order to see the exact
list. However, some of the more special headers are: </P>

<DL>
<DT><CODE>Allow</CODE>
<DD>Builds a list of allowed methods for this entity
<DT><CODE>ContentEncoding</CODE>
<DD>
<DT><CODE>ContentLanguage</CODE>
<DD>Builds a list of natural languages
<DT><CODE>ContentLength</CODE>
<DD>This parameter is now passed
<DT><CODE>ContentType</CODE>
<DD>The <CODE>ContentType</CODE> header now support the <CODE>charset</CODE> parameter and the
<CODE>level</CODE> parameter, however none of them are used by the <A HREF="#HTML">HTML parser</A>
<DT><CODE>Date</CODE>, <CODE>Expires</CODE>, <CODE>RetryAfter</CODE>, and <CODE>LastModified</CODE>
<DD>All date and time headers are parsed understanding the following formats: RFC 1123, RFC 850,
ANSI C's asctime(), and delta time. The latter is a non-negative integer indicating seconds after
the message was received.  Note, that it is <EM>always</EM> for the application to issue a new
request as a function of any of the date and time headers..
<DT><CODE>DerivedFrom, Version</CODE>
<DD>For handling version control when managing collaborative works using HTTP.
</DL>  

<H3>Parsing Additional Headers</H3>

In many cases, if you have registered an extra set of headers to be generated, you are also in a
situation where you would like to handle the result that is returned by the remote server. As we will
describe in this section, the Library provides a very similar interface to the one presented above
for generating extra headers. <P>

Again, the API for handling extra headers is provided by the <A
HREF="../../Implementation/HTHeader.html">Header Manager</A> and is based on managing list objects,
just like we have seen many times before. Each time a request is received, and a unknown header is
encountered by the internal <A HREF="../../Implementation/HTMIME.html">MIME parser</A>, the Library
looks to see if a list of callback functions has been registered to parse additional
metainformation. In case a parser is found for this particular header, the call back is called with
the header and all parameters that might follow it. As MIME headers can contain line wrappings, the
<A HREF="../../Implementation/HTMIME.html">MIME parser</A> canonicalizes the header line before the
callback function is called which makes the job easier for the callback function.<P>

Exactly as for the header generators you can <EM>add</EM> and <EM>delete</EM> an element, which also
in this case is a callback function. This function has a special definition which is given by

<PRE>
typedef int HTParserCallback (HTRequest * request, CONST char * token);
</PRE>

The request object is the current request being handled and the token is the header that was
encountered together with all parameters following it. The callback can return a value to the
Library by using the return code of the callback function. Currently there are two return values
recognized by the Library:

<UL>
<LI><CODE>HT_OK</CODE> if the token is received and understood
<LI><CODE>HT_ERROR</CODE> if the callback encounters a fatal error and any further parsing should be stopped.
</UL>

While in the callback function, the application can start other requests or even kill the current
request if required. We can register a callback function by using the following function:

<PRE>
extern BOOL HTParser_add (HTList *		parsers,
			  CONST char *       	token,
			  BOOL			case_sensitive,
			  HTParserCallback *	callback);
</PRE>

Again, the first argument is a list as we have seen before. The token is a specific token by which
the callback function should be called. This token can contain a wild card (*) which will match zero
or more arbitrary characters. You can also specify whether the token should be matched using a case
sensitive or case insensitive matching algorithm. Let's look at an example of how to register a
parser callback function:

<PRE>
HTParser_add(mylist, "PICS-*", NO, myparser);
</PRE>

This registers the <CODE>myparser</CODE> function as being capable of handling all tokens starting
with "PICS", "PiCs", "pics", for example:

<PRE>
	PICS-start
	pics-Token
	PICS
</PRE>

As for header generators, you can unregister a callback function by using the following function:

<PRE>
extern BOOL HTParser_delete (HTList * parsers, CONST char * token);
</PRE>

<H2>Enabling Preferences</H2>

Exactly as for <A HREF="Prefs.html">Request Preferences</A>, all we have done until now is to show
how we can register sets of preferences. However, we still need to define where and when to actually
let the Library use the preferences. Again, this can be done in two ways: Globally or locally. When
assigning a set of preferences, for example the set of natural languages, it can either be assigned
to all future requests (globally) or to a specific request (locally). The preferences can also
partly be assigned globally and partly locally so that the most common preferences are registered
globally and only some preferences specific to a single request is then added by registering the
sets locally. <P>

Here we will only show how to handle the global registration as the local registration is part of
the description of the request object.

<H3>Additional Header Parsers</H3>

<PRE>
extern void HTHeader_setParser (HTList * list);
extern HTList * HTHeader_parser (void);
</PRE>

<H3>Additional Header Generatores</H3>

<PRE>
extern void HTHeader_setGenerator (HTList * list);
extern HTList * HTHeader_generator (void);
</PRE>

<H2>Cleaning up Preferences</H2>

As for request preferences, the application is responsible for setting up the sets of additional
header generation and parsing, and it is also responsible for deleting them once they are not needed
anymore, for example when the application i s closing down, or the user has changed them. The
Library provides two mechanisms for cleaning up old lists: It can either be done by invoking
separate methods on each set of preferences, or it can be done in a batch of all globally registered
preferences or all locally registered preferences relative to a single request. In this context, a
batch is the total set of registered converters, encoder, character sets, and languages. Here we
will only show how to cleanup preferences set-wise and as a globally batch of preferences. We leave
the local cleanup until we have described the request object later in this guide. <P>

As for the other deletion methods, when they have been called you can nor more use the lists as they
are not pointing to valid places in the memory. The first mechanism for cleaning up lists is by
calling the cleanup method of each preference as indicated below:

<H3>Header Parsers</H3>

<PRE>
extern BOOL HTParser_delete (HTList * parsers, CONST char * token);
extern BOOL HTParser_deleteAll (HTList * parsers);
</PRE>

<H3>Header Generators</H3>

<PRE>
extern BOOL HTGenerator_delete (HTList * gens, HTPostCallback * callback);
extern BOOL HTGenerator_deleteAll (HTList * gens);
</PRE>

The easy way of cleaning up all global lists at once is calling the following function

<PRE>
extern void HTHeader_deleteAll (void);
</PRE>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 

<HTML>
<HEAD>
<TITLE>User Guide - Request Callback functions</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 29-Jan-1996 -->
<NEXTID N="z78">
</HEAD>
<BODY>

<A HREF="../../../"><IMG ALT="W3C" SRC="../../../Icons/WWW/w3c_48x48.gif"></A>
<A HREF="../../"><IMG ALT="Lib" SRC="../../../Icons/WWW/Lib48x.gif"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Request Callback functions</H1>

As we have seen in the previous chapters, the core part of the Library knows nothing about how to
access, for example, a HTML document from a remote server. All this depends on what the application
has registered. In many situations there are a number of things to do before a request is actually
sent over the wire. For example we might already have the document in a cache or we might have some
translation of the URL so that we don't go directly to the remote server. The latter case includes
redirection of a request to go through a proxy server or a gateway. Likewise, when a request is
terminated, we might want to keep a log of the request and the result, update history lists
etc. <P>

The Library does provide a large amount of such pre- and post processing modules. However, the exact
amount used by an application depends on the purpose of the application. Simple script-like
applications typically do not need any history mechanism etc. Therefore these modules are not a part
of the core but instead they can be registered as all other preferences. The <A
HREF="../../Implementation/HTNet.html">Net Manager</A> provides functionality for registering a set
of callback functions that can be called <EM>before</EM> and <EM>after</EM> a request has been
executed. Of course, the result of a pre-processing might be that the request does not have to be
executed at all in which case the request can be terminated before the protocol module is called to
execute the request. <P>

<H2>Generic Handling of Callbacks</H2>

The registration of callback functions is handled by the <A HREF="../../Implementation/HTNet.html">
HTNet Manager</A> and it is (of course) based on lists as we have seen so many times before. A
callback function can be added to a list by using the following function:

<PRE>
extern BOOL HTNetCall_add (HTList * list, HTNetCallback * cbf, int status);
</PRE>

The callback function has to be of type <CODE>HTNetCallback</CODE> which is defined as

<PRE>
typedef int HTNetCallback (HTRequest * request, int result);
</PRE>

This means that a callback function is called with the current request object and the result of the
request. Now, if the callback is registered as a <EM>pre</EM> callback then we obviously do not yet
have a result and the functions is called with the code <EM>HT_OK</EM>. However, if it is a
<EM>post</EM> callback function then the result code may take any of the following values:

<DL>
<DT>HT_ERROR
<DD>An error occured
<DT>HT_INTERRUPTED
<DD>The request was interrupted
<DT>HT_LOADED
<DD>The document was loaded
<DT>HT_NO_DATA
<DD>OK, but no data
<DT>HT_RETRY
<DD>Retry request after at a later time
<DT>HT_PERM_REDIRECT
<DD>The request has been permanently redirected and we send back the new URL
<DT>HT_TEMP_REDIRECT
<DD>The request has been temporarily redirected and we send back the new URL
<DT>HT_NO_ACCESS
<DD>The request could not be fulfilled because it didn't contain sufficient credentials
</DL>

When a callback function is registered, it may be registered with a status code for which it is to
be called. This means that there may be different callback functions to handle error situations,
redirections etc. The status code may also take any of the values above, or <EM>HT_ALL</EM> if it is
to be called always. <P>

A callback function may return any code it likes, but <B>IF</B> the return code is different than
<EM>HT_OK</EM>, then the callback loop is stopped. If we are in the <EM>before</EM> loop and a
function returns anything else than <EM>HT_OK</EM> then we immediately jump to the <EM>after</EM>
loop <B>passing</B> the last return code from the <EM>before</EM> loop. <P>

Likewise, a callback function can be removed from a list using the following function:

<PRE>
extern BOOL HTNetCall_delete (HTList * list, HTNetCallback *cbf);
</PRE>

or if you simply want to remove all functions from a list then you can use

<PRE>
extern BOOL HTNetCall_deleteAll (HTList * list);
</PRE>

<A NAME="pre"><H2>Pre-Request Callbacks</H2></A>

When a request has been issued there are a number of things that an application might want to do
with the request before it actually goes on the wire, for example to talk to a remote HTTP
server. Examples are checking if the object already is kept in a cache managed by the application,
if the request should be redirected to a proxy or a gateway, or there is some other kind of
translation of the URL taking place. The Library provides a variety of modules that handles many
common place translations such as <EM>redirection of URLs</EM> and <EM>caching</EM>. The full list
of modules are:

<H3>Rule File Management</H3>

An application can be setup by using a rule file, also known as a configuration file. This is for
example the case with the W3C httpd and the W3C Line Mode Browser. The <A
HREF="../../Implementation/HTRules.html">Rules module</A> provides basic support for configuration
file management and the application can use this is desired. The module is not referred to by the
Library. Reading a rule file is implemented as a stream converter so that a rule file can come from
anywhere, even across the network!

<A NAME="proxying"><H3>Proxies and Gateways</H3></A>

Applications do not have to provide native support for all protocols, they can in many situations
rely on the support of proxies and gateways to help doing the job. Proxy servers are often used to
carry client requests through a firewall where they can provide services like corporate caching and
other network optimizations. Both Proxy servers and gateways can serve as "protocol translators"
which can convert a request in the main Web protocol, HTTP, to an equivalent request in another
protocol, for example NNTP, FTP, or Gopher. In a later section we will see how to set up the Proxy
servers and gateways using the <A HREF="../../Implementation/HTProxy.html">Proxy module</A>. <P>

As a HTTP request looks different when it is directed to a proxy server than to a origin server, the
HTTP module needs to know whether it is talking to a proxy for this particular request or not. You
can specify in a request object whether a proxy is being used or not by using the following methods:

<PRE>
extern void HTRequest_setProxing (HTRequest * request, BOOL proxying);
extern BOOL HTRequest_proxying (HTRequest * request);
</PRE>

<H3>Cache Manager</H3>

Caching is a required part of any efficient Internet access applications as it saves bandwidth and
improves access performance significantly in almost all types of accesses.  The Library supports two
different types of cache: The memory cache and the file cache. The two types differ in several ways
which reflects their two main purposes: The memory cache is for short term storage of graphic
objects whereas the file cache is for intermediate term storage of data objects. Often it is
desirable to have both a memory and a file version of a cached document, so the two types do not
exclude each other. The <A HREF="../../Implementation/HTCache.html">HTCache module</A> provides a
basic cache that can be used by an application.

<H3>Register a list of BEFORE Callbacks</H3>

Until now, we have only described how to build a list of callback functions. We will now describe
how to setup a list as either a pre processing set of callback function (the <EM>BEFORE</EM> loop,
or a post processing set (<EM>AFTER</EM> loop). A set of callback functions can be registered to be
called before the request is started by using the following function:

<PRE>
extern BOOL HTNet_setBefore	(HTList * list);
</PRE>

In many cases you know when you register a callback function that this is a function that you always
want to be called when either a request starts up or terminates. In the former case you can simply
register the callback directly using the following function:

<PRE>
extern BOOL HTNetCall_addbefore	(HTNetCallback *cbf, int status);
</PRE>

<H2>Post-Request Callbacks</H2>

When a request is terminated, the application often has to do some action as a result of the request
(and of the result of the request). The Application part of the Library provides two following
modules to handle <EM>logging</EM> and <EM>history management</EM>. You can register a <EM>POST
request handler</EM> in the <A HREF="../../Implementation/HTNet.html">Net Manager</A> as described
in the <A HREF="./">User's Guide</A>. The set of modules provided by the Library is:<P>

<H3>Logging</H3>

Often it is required to log the requests issued to the Library. This can either be the case if the
application is a server or it can also be useful in a client application. The <A
HREF="../../Implementation/HTLog.html">HTLog Module</A> provides a simple logging mechanism which
can be enabled if needed.

<H3>History Management</H3>

Another type of logging is keeping track of which documents a user has visited when browsing along
on the Web. The <A HREF="../../Implementation/HTHist.html">HTHistory module</A> provides a basic set
of functionality to keep track of multiple linear history lists.

<H3>Register a list of AFTER Callbacks</H3>

The registration of a set of callback functions to be called when a request has terminated is
handled in very much the same way:

<PRE>
extern BOOL HTNet_setAfter	(HTList * list);
extern BOOL HTNetCall_addBefore (HTNetCallback *cbf, int status);
</PRE>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML>
<HTML>
<HEAD>
<TITLE>User Guide - Error Messages</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen,  7-Feb-1996 -->
<NEXTID N="z78">
</HEAD>
<BODY>

<A HREF="../../../"><IMG ALT="W3C" SRC="../../../Icons/WWW/w3c_48x48.gif"></A>
<A HREF="../../"><IMG ALT="Lib" SRC="../../../Icons/WWW/Lib48x.gif"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Error Messages</H1>

The Library deals with two categories of errors: user errors and application errors. The former are
all the errors that can occur when the Library is used in a "real" environment where network
connections can disappear, disks can get full, and memory can get exhausted. The letter type of
errors are at a lower level including invalid arguments passed to procedures, missing function
calls, or any other application misbehavior. In this section we will examine the Library <A
HREF="../../Implementation/HTError.html">Error Manager</A> which handles user errors. In a later
section we will have a look at how to control the application errors at an application debug
level using trace messages.<P>

As a part of the core Library, the error object is intended to pass information about errors and
messages occuring in the Library back to the application. Each error is kept as an object so
multiple errors can be nested together using the well-known <A
HREF="../../Implementation/HTList.html">HTList object</A>. Nested error management can be used to
build complicated error messages which an arbitrary level of details, for example:

<PRE>
	This URL could not be retrieved: http://www.foo.com
	    Reason: The host name could not be resolved
	        Reason: DNS service is not available
</PRE>

The principle behind the error manager is exactly like any other registration module in the Library
in that it creates an object and binds it to a list that the caller provides. Often, errors are
related to a specific request object and each request object will therefore keep its own list of
errors. However, errors can also be maintained as separate lists which are not directly related to a
request, for example, the application can keep its own list of errors independent of any Library
errors.  <P>

Errors are roughly categorized into two classes: system errors and other errors. System errors
include all errors that occur while interacting with the operating system. Often these errors occurs
as a result of insufficient availability or authentication to a system resource. In many operating
systems, the system provides a set of error messages which is associated with an error code made
available to the application via the <EM>errno</EM> variable or equivalent. All other errors are
registered with an error message belonging to the Library Error manager. Note, that there are no
difference in how system errors and other errors are treated, they are the same data objects and
can be registered together with no exception.

<H2>Registering Errors</H2>

Now let's take a look at how a generic error list is maintained. Normal errors can be registered
using the following function:

<PRE>
extern BOOL HTError_add		(HTList *	list,
				 HTSeverity	severity,
				 BOOL		ignore,
				 int		element,
				 void *		parameter,
				 unsigned int	length,
				 char *		where);
</PRE>

The first argument is a list object and as always, we need to create a list object using the
<CODE>HTList_new </CODE> method. The next element is an indication of how serious the error is in
the situation where it occured. Classification of errors are known from many operating systems, for
example VMS, and it gives the application the opportunity to decide whether the current operation
should be continued or aborted. The Library provides four severity categories:

<PRE>
typedef enum _HTSeverity {
    ERR_FATAL,
    ERR_NON_FATAL,
    ERR_WARN,
    ERR_INFO
} HTSeverity;
</PRE>

It is not always that an error is an error immediately when it occurs. In some situations it might
first become an error later in the process depending on the outcome of other factors - or it might
be circumvented so that no special action is required. The <EM>ignore</EM> flag provides this
functionality in that an error can be registered at any time with the notion: "Register this error
but ignore it for now". <P>

The <CODE>element</CODE> argument is an index into a table of all error messages. This table is
maintained in the <A HREF="../../Implementation/HTError.c">HTError Module</A> and contains an error
message together with a URl that might be included in an error message presented to the user. The
values of the <CODE>element</CODE> argument itself is given by the <CODE>HTErrorElement</CODE>
enumeration definition in the <A HREF="../../Implementation/HTEvntrg.html">HTEvntrg Module</A>. <P>

The next two arguments are used to register any parameters associated with the error. This can for
example be the file name of a file which could not be opened, a URL which could not be accessed
etc. By letting the parameter be a void pointer together with a length indication, the parameter can
be an arbitrary data object. The last argument is a location description to indicate where the error
occured. Often this is the name of the function or a module. <P>

One thing, we didn't mention when describing the <A HREF="Request.html">request object</A> was that
the <A HREF="../../Implementation/HTReq.html">Request Object</A> provides a similar function for
directly associating an error object with a request object. These functions uses request objects and
not a list as the basic data object and hence the caller does not have to worry about creating or
assigning the list to the request object; this is done automatically. The request version of how to
register an error looks very much like its more generic companion, and it should not be necessary
to explain the arguments any further.

<PRE>
extern BOOL HTRequest_addError (HTRequest * 	request,
				HTSeverity	severity,
				BOOL		ignore,
				int		element,
				void *		par,
				unsigned int	length,
				char *		where);
</PRE>

System errors can be registered in very much the same way as described above, but the set of
parameters is a bit smaller and hopefully a bit easier to handle. The registration function is
defined as:

<PRE>
extern BOOL HTError_addSystem (HTList *		list,
			       HTSeverity 	severity,
			       int		errornumber,
			       BOOL		ignore,
			       char *		syscall);
</PRE>

The only difference is the <CODE>errornumber</CODE> argument which, as described above, in many
situations is provided by the operating system, for example as a <EM>errno</EM> variable. The
<CODE>syscall</CODE> is simply the name of the function. Also this function has a mirror function in
the <A HREF="../../Implementation/HTReq.html">HTRequest object</A>, and again they look very much
alike:

<PRE>
extern BOOL HTRequest_addSystemError (HTRequest * 	request,
				      HTSeverity 	severity,
				      int		errornumber,
				      BOOL		ignore,
				      char *		syscall);
</PRE>

Let's take a look at two examples of registering errors. The first example registers an
informational error message explaining that the HTTP module received a redirection notification from
the remote HTTP server. The first example uses the Request versions of the error registration
functions, and the second example uses the generic versions:

<PRE>
BOOL HTTPRedirect (HTRequest * request, int status, char * location)
{
    if (location) {
	if (status == 301) {
	    HTRequest_addError(request, ERR_INFO, NO, HTERR_MOVED,
			       location, strlen(location), "HTTPRedirect");
	} else if (status == 302) {
	    HTRequest_addError(request, ERR_INFO, NO, HTERR_FOUND,
			       location, strlen(location), "HTTPRedirect");
	}
	return YES;
    } else {
	HTRequest_addError(request, ERR_FATAL, NO, HTERR_BAD_REPLY,
			   NULL, 0, "HTTPRedirect");
	return NO;
    }
}
</PRE>

The second example shows how to register a system error:

<PRE>
BOOL HTReadDir (HTRequest * request, const * directory)
{ 
    DIR *dp;
    if ((dp = opendir(directory))) {
	STRUCT_DIRENT * dirbuf;
	while ((dirbuf = readdir(dp))) {

	    /* Read Directory */

	}
	closedir(dp);
	return YES;
    } else {
	HTError_addSystem(errorlist,  ERR_FATAL, errno, NO, "opendir");
	return NO;
    }
}
</PRE>

<H2>Error Messages</H2>

Until now we have concentrated on how to register a set of errors in a list and how to associate
errors with a request object. Another important thing about errors is that they often are to be
presented to the user. The error manager can be configured to show almost any combination of the
parameters in an error object, and all the flags are put together in a big enumeration:

<PRE>
typedef enum _HTErrorShow {
    HT_ERR_SHOW_FATAL,		/* Show only fatal errors */
    HT_ERR_SHOW_NON_FATAL,	/* Show non fatal and fatal errors */
    HT_ERR_SHOW_WARNING,	/* Show warnings, non fatal, and fatal errors */
    HT_ERR_SHOW_INFO,		/* Show all of errors */
    HT_ERR_SHOW_PARS,		/* Show any parameters (if any) */
    HT_ERR_SHOW_LOCATION,	/* Show the location where the error occured */
    HT_ERR_SHOW_IGNORE,		/* Show errors even if they are ignored */
    HT_ERR_SHOW_FIRST,		/* Show only the first registered error */
    HT_ERR_SHOW_LINKS		/* Show any HTML links (if any) */
    HT_ERR_SHOW_DEFAULT,	/* Default level of details *
    HT_ERR_SHOW_DETAILED,	/* Somewhat detailed level */
    HT_ERR_SHOW_DEBUG,		/* Very detailed */
} HTErrorShow;
</PRE>

The last three entries in the enumeration list are only for the convenience of the application. They
provide some useful default values for how error messages <EM>can</EM> be presented to the user. The
setup can be modified using the following functions:

<PRE>
extern HTErrorShow HTError_show (void);
extern BOOL HTError_setShow (HTErrorShow mask);
</PRE>

The actual generation of error messages often involves a platform dependent interface including
special windows etc. In order to keep the error manager itself completely platform independent, the
error presentation functionality is part of the <A
HREF="../../Implementation/HTAlert.html">Messaging Module</A> which is described in detail later in
this guide.

<H2>Data Methods</H2>

The <A HREF="../../Implementation/HTError.html">Error manager</A> contains a large set of
configuration options and methods for accessing information about registered lists. This guide is
not intended to describe every single public function, so here we will only present the methods in a list. Often they are self explanatory, so you can probably get a clue of what is going on anyway!

<PRE>
extern BOOL HTError_doShow		(HTError * info);
extern BOOL HTError_ignoreLast		(HTList * list);
extern BOOL HTError_setIgnore		(HTError * info);
extern int HTError_index		(HTError * info);
extern HTSeverity HTError_severity	(HTError * info);
extern int HTError_parameter		(HTError * info, void *parameter);
extern CONST char * HTError_location	(HTError * info);
</PRE>

<H2>Cleaning up Errors</H2>

In case you are using the generic error interface (<CODE>HTError_add</CODE> and
<CODE>HTError_addSystem</CODE>), the cleanup is done exactly like for all other list based
registration mechanisms in the Library. In case you are using the request specific version, the
request manager both handles creating and deletion of error lists, so you do not have to do
anything. The generic interface for cleaning up looks like:

<PRE>
extern BOOL HTError_deleteAll (HTList * list);
extern BOOL HTError_deleteLast (HTList * list);
</PRE>

In the next section, we will see how to display errors in the application along with other user
information such as progress reports etc.

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML>
<HTML>
<HEAD>
<TITLE>User Guide - Using Streams</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 16-Nov-1995 -->
<NEXTID N="z78">
</HEAD>
<BODY>

<A HREF="../../../"><IMG ALT="W3C" SRC="../../../Icons/WWW/w3c_48x48.gif"></A>
<A HREF="../../"><IMG ALT="Lib" SRC="../../../Icons/WWW/Lib48x.gif"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>The Format Manager</H1>

<B>MORE</B>

<UL>
<LI>setting up request streams
<LI>memory management
<LI>examples
<LI>explain why converters have an input and an output format: chains
</UL>


<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML>
<HTML>
<HEAD>
<TITLE>Using - Anchors</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 16-Nov-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Using Anchors</H1>

<B>MORE</B>

<UL>
<LI>what do they represent
<LI>where and when to use
<LI>How to create and handle
<LI>relations between links
<LI>memory management
</UL>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>Using the W3C Reference Library</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 17-Jan-1996 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>The Request Object</H1>

The request object contains all the information needed to define a request the parameters to be used
when requesting a resource from the network or local file system. When a request is handled, all
kinds of things about it need to be passed along together with a request.  <P>

<H2>Request a resource</H2>

This is an internal routine, which has an address AND a matching anchor.  (The public routines are
called with one OR the other.)

<PRE>
extern BOOL HTLoad (HTRequest * request, HTPriority priority, BOOL recursive);
</PRE>

<H2>Creation and Deletion Methods</H2>

The request object is intended to live as long as the request is still
active, but can be deleted as soon as it has terminatedk, for example
in one of the request termination callback functions as described in
the <A HREF="../../Implementation/HTNet.html">Net Manager</A>. Only the anchor object stays
around after the request itself is terminated.

<H3>Create new Object</H3>

Creates a new request object with a default set of options -- in most
cases it will need some information added which can be done using the
methods in this module, but it will work as is for a simple request.

<PRE>
extern HTRequest * HTRequest_new (void);
</PRE>

<H3>Delete Object</H3>

This function deletes the object and cleans up the memory.

<PRE>
extern void HTRequest_delete (HTRequest * request);
</PRE>

<H2>Bind an Anchor to a Request Object</H2>

Every request object has an anchor associated with it. The anchor
normally lives until the application terminates but a request object
only lives as long as the request is being serviced.

<PRE>
extern void HTRequest_setAnchor (HTRequest *request, HTAnchor *anchor);
extern HTParentAnchor * HTRequest_anchor (HTRequest *request);
</PRE>

<H2>Set the Method</H2>

The Method is the operation to be executed on the requested
object. The default set if the set of operations defined by the HTTP
protocol, that is "GET", "HEAD", "PUT", "POST", "LINK", "UNLINK", and
"DELETE" but many of these can be used in other protocols as well. The
important thing is to think of the requested element as an object on
which you want to perform an operation. Then it is for the specific
protocol implementation to try and carry this operation out. However,
not all operations can be implemented (or make sense) in all
protocols. <P>

Methods are handled by the <A HREF="../../Implementation/HTMethod.html">Method Module</A>,
and the default value is "GET".

<PRE>
extern void HTRequest_setMethod (HTRequest *request, HTMethod method);
extern HTMethod HTRequest_method (HTRequest *request);
</PRE>

<H2>Update, Reload, or Refresh a Document</H2>

The Library has two concepts of caching: in memory and on file. When
loading a document, this flag can be set in order to define who can
give a response to the request. <EM>IMS</EM> means that a
"If-Modified-Since" Header is used in a HTTP request.

<PRE>
typedef enum _HTReload {
    HT_ANY_VERSION	= 0x0,		/* Use any version available */
    HT_MEM_REFRESH	= 0x1,		/* Reload from file cache or network */
    HT_CACHE_REFRESH	= 0x2,		/* Update from network with IMS */
    HT_FORCE_RELOAD	= 0x4		/* Update from network with no-cache */
} HTReload;

extern void HTRequest_setReloadMode (HTRequest *request, HTReload mode);
extern HTReload HTRequest_reloadMode (HTRequest *request);
</PRE>

<H2>Max number of Retrys for a Down Load</H2>

Automatic reload can happen in two situations:

<UL>
<LI>The server sends a redirection response
<LI>The document has expired
</UL>

In order to avoid the Library going into an infinite loop, it is
necessary to keep track of the number of automatic reloads. Loops can
occur if the server has a reload to the same document or if the server
sends back a Expires header which has already expired. The default
maximum number of automatic reloads is 6.

<PRE>
extern BOOL HTRequest_setMaxRetry (int newmax);
extern int  HTRequest_maxRetry (void);
extern BOOL HTRequest_retry (HTRequest *request);
</PRE>

<H2>Retry Request After</H2>

Some services, for example HTTP, can in case they are unavailable at
the time the request is issued send back a time and date stamp to the
client telling when they are expected to back online. In case a
request results in a HT_RETRY status, the application can use any time
indicated in this field to retry the request at a later time. The
Library does not initiate any request on its own - it's for the
application to do. The time returned by this function is in calendar
time or -1 if not available.

<PRE>
extern time_t HTRequest_retryTime (HTRequest * request);
</PRE>

<H2>Accept Headers</H2>

The Accept family of headers is an important part of HTTP handling the
format negotiation. The Library supports both a global set of accept
headers that are used in <EM>all</EM> HTTP requests and a local set of
accept headers that are used in specific requests only. The global
ones are defined in the <A HREF="../../Implementation/HTFormat.html">Format
Manager</A>.  <P>

Each request can have its local set of accept headers that either are
added to the global set or replaces the global set of accept
headers. Non of the headers <EM>have</EM> to be set. If the global set
is sufficient for all requests then this us perfectly fine. If the
parameter "override" is set then only local accept headers are used,
else <EM>both</EM> local and global headers are used.

<H3>Content Types</H3>

Th <EM>local</EM> list of specific conversions which the format
manager can do in order to fulfill the request.  It typically points
to a list set up on initialisation time for example by <A
HREF="../../Implementation/HTInit.html">HTInit()</A>. There is also a <A
HREF="../../Implementation/HTFormat.html#z17"><EM>global</EM></A> list of conversions which
contains a generic set of possible conversions.

<PRE>
extern void HTRequest_setFormat	(HTRequest *request, HTList *type, BOOL override);
extern HTList * HTRequest_format (HTRequest *request);
</PRE>

<H3>Content Encodings</H3>

The list of encodings acceptable in the output stream.

<PRE>
extern void HTRequest_setEncoding (HTRequest *request, HTList *enc, BOOL override);
extern HTList * HTRequest_encoding (HTRequest *request);
</PRE>

<H3>Content-Languages</H3>

The list of (human) language values acceptable in the response. The default
is all languages.

<PRE>
extern void HTRequest_setLanguage (HTRequest *request, HTList *lang, BOOL override);
extern HTList * HTRequest_language (HTRequest *request);
</PRE>

<H3>Charset</H3>

The list of charsets accepted by the application

<PRE>
extern void HTRequest_setCharset (HTRequest *request, HTList *charset, BOOL override);
extern HTList * HTRequest_charset (HTRequest *request);
</PRE>

<H2>Handling Metainformation (RFC822 Headers)</H2>

The Library supports a large set of headers that can be sent along
with a request (or a response for that matter). All headers can be
either disabled or enabled using bit flags that are defined in the
following.

<H3><A NAME="gnhd">General HTTP Header Mask</A></H3>

There are a few header fields which have general applicability for
both request and response mesages, but which do not apply to the
communication parties or theentity being transferred. This mask
enables and disables these headers. If the bit is not turned on they
are not sent. All headers are optional and the default value is <EM>NO
GENERAL HEADERS</EM>

<PRE>
typedef enum _HTGnHd {
    HT_DATE		= 0x1,
    HT_FORWARDED	= 0x2,
    HT_MESSAGE_ID	= 0x4,
    HT_MIME		= 0x8,
    HT_NO_CACHE		= 0x10					   /* Pragma */
} HTGnHd;

#define DEFAULT_GENERAL_HEADERS		0

extern void HTRequest_setGnHd (HTRequest *request, HTGnHd gnhd);
extern void HTRequest_addGnHd (HTRequest *request, HTGnHd gnhd);
extern HTGnHd HTRequest_gnHd (HTRequest *request);
</PRE>

<H3><A NAME="rqhd">Request Headers</A></H3>

The request header fields allow the client to pass additional
information about the request (and about the client itself) to the
server. All headers are optional but the default value is all request
headers if present <EM>except</EM> <CODE>From</CODE> and
<CODE>Pragma</CODE>.

<PRE>
typedef enum _HTRqHd {
    HT_ACCEPT_TYPE	= 0x1,
    HT_ACCEPT_CHAR	= 0x2,
    HT_ACCEPT_ENC	= 0x4,
    HT_ACCEPT_LAN	= 0x8,
    HT_FROM		= 0x10,
    HT_IMS		= 0x20,
    HT_ORIG_URI		= 0x40,
    HT_REFERER		= 0x80,
    HT_USER_AGENT	= 0x200
} HTRqHd;

#define DEFAULT_REQUEST_HEADERS \
HT_ACCEPT_TYPE+HT_ACCEPT_CHAR+HT_ACCEPT_ENC+HT_ACCEPT_LAN+HT_REFERER+HT_USER_AGENT

extern void HTRequest_setRqHd (HTRequest *request, HTRqHd rqhd);
extern void HTRequest_addRqHd (HTRequest *request, HTRqHd rqhd);
extern HTRqHd HTRequest_rqHd (HTRequest *request);
</PRE>

<H3><A NAME="enhd">Entity Header Mask</A></H3>

The entity headers contain information about the object sent in the
HTTP transaction. See the <A HREF="../../Implementation/HTAnchor.html">Anchor module</A>,
for the storage of entity headers. This flag defines which headers are
to be sent in a request together with an entity body. All headers are
optional but the default value is <EM>ALL ENTITY HEADERS IF
PRESENT</EM>

<PRE>
typedef enum _HTEnHd {
    HT_ALLOW		= 0x1,
    HT_CONTENT_ENCODING	= 0x2,
    HT_CONTENT_LANGUAGE	= 0x4,
    HT_CONTENT_LENGTH	= 0x8,
    HT_CTE		= 0x10,			/* Content-Transfer-Encoding */
    HT_CONTENT_TYPE	= 0x20,
    HT_DERIVED_FROM	= 0x40,
    HT_EXPIRES		= 0x80,
    HT_LAST_MODIFIED	= 0x200,
    HT_LINK		= 0x400,
    HT_TITLE		= 0x800,
    HT_URI		= 0x1000,
    HT_VERSION		= 0x2000
} HTEnHd;

#define DEFAULT_ENTITY_HEADERS		0xFFFF			      /* all */

extern void HTRequest_setEnHd (HTRequest *request, HTEnHd enhd);
extern void HTRequest_addEnHd (HTRequest *request, HTEnHd enhd);
extern HTEnHd HTRequest_enHd (HTRequest *request);
</PRE>

<H3>Referer Field</H3>

If this parameter is set then a `Referer: &lt;parent address&gt; can
be generated in the request to the server, see <A
HREF="../../../Protocols/"> HTTP Protocol</A>

<PRE>
extern void HTRequest_setParent (HTRequest *request, HTParentAnchor *parent);
extern HTParentAnchor * HTRequest_parent (HTRequest *request);
</PRE>

<H3>Extra Headers</H3>

Extra header information can be send along with a request using this
variable. The text is sent as is so it must be preformatted with
&lt;CRLF&gt; line terminators. This will get changed at some point so
that you can register a header together with a handler in the MIME
parser.

<PRE>
extern void HTRequest_setExtra (HTRequest *request, char *extra);
extern char *HTRequest_extra (HTRequest *request);
</PRE>

<H2>Streams From Network to Application</H2>

<H3>Default Output Stream</H3>

The output stream is to be used to put data down to as they come in
<B>from</B> the network and back to the application. The default value
is <CODE>NULL</CODE> which means that the stream goes to the user
(display).

<PRE>
extern void HTRequest_setOutputStream (HTRequest *request, HTStream *output);
extern HTStream *HTRequest_OutputStream (HTRequest *request);
</PRE>

The desired format of the output stream. This can be used to get
unconverted data etc. from the library. If <CODE>NULL</CODE>, then <A
HREF="../../Implementation/HTFormat.html#FormatTypes">WWW_PRESENT</A> is default value.

<PRE>
extern void HTRequest_setOutputFormat (HTRequest *request, HTFormat format);
extern HTFormat HTRequest_OutputFormat (HTRequest *request);
</PRE>

<H3>Debug Stream</H3>

All object bodies sent from the server with status codes different
from <CODE>200 OK</CODE> will be put down this stream. This can be
used for redirecting body information in status codes different from
"200 OK" to for example a debug window. If the value is NULL (default)
then the stream is not set up.

<PRE>
extern void HTRequest_setDebugStream (HTRequest *request, HTStream *debug);
extern HTStream *HTRequest_DebugStream (HTRequest *request);
</PRE>

The desired format of the error stream. This can be used to get
unconverted data etc. from the library. The default value if
<CODE>WWW_HTML</CODE> as a character based only has one WWW_PRESENT.

<PRE>
extern void HTRequest_setDebugFormat (HTRequest *request, HTFormat format);
extern HTFormat HTRequest_DebugFormat (HTRequest *request);
</PRE>

<H2><A NAME="context">Context Swapping</A></H2>

In multi threaded applications it is often required to keep track of
the context of a request so that when the Library returns a result of
a request, it can be put into the context it was in before the request
was first passed to the Library. This call back function allows the
application to do this.

<PRE>
typedef int HTRequestCallback (HTRequest * request, void *param);

extern void HTRequest_setCallback (HTRequest *request, HTRequestCallback *cb);
extern HTRequestCallback *HTRequest_callback (HTRequest *request);
</PRE>

The callback function can be passed an arbitrary pointer (the void
part) which can describe the context of the current request object. If
such context information is required then it can be set using the
following methods:

<PRE>
extern void HTRequest_setContext (HTRequest *request, void *context);
extern void *HTRequest_context (HTRequest *request);
</PRE>

<A NAME="preemptive"><H2>Preemptive or Non-preemptive Access</H2></A>

A access scheme is registered with a default for using either preemptive (blocking I/O) or
non-premitve (non-blocking I/O). This is basically a result of the implementation of the protocol
module itself and is explained in the section <A HREF="Methods.html#preemptive">Registering Access
Schemes</A>. However, if non-blocking I/O is the default then some times it is nice to be able to
set the mode to blocking instead. For example when loading the first document (the home page) then
blocking can be used instead of non-blocking.

<PRE>
extern void HTRequest_setPreemptive (HTRequest *request, BOOL mode);
extern BOOL HTRequest_preemptive (HTRequest *request);
</PRE>

<H2>Format Negotiation</H2>

When accessing the local file system, the Library is capable of
performing content negotioation as described by the HTTP
protocol. This is mainly for server applications, but some client
applications might also want to use content negotiation when accessing
the local file system. This method enables or disables content
negotiation - the default value is <EM>ON</EM>.

<PRE>
extern void HTRequest_setNegotiation (HTRequest *request, BOOL mode);
extern BOOL HTRequest_negotiation (HTRequest *request);
</PRE>

<H2>Error Manager Information</H2>

The error manager keeps a list (called an error stack) of all errors
and warnings occured during a request. The list of errors can be
accessed for generating an error message by the following function.

<PRE>
extern HTList *HTRequest_errorStack (HTRequest *request);
</PRE>

<H2>Bytes Read in Current Request</H2>

This function returns the bytes read in the current request. For a
deeper description of what the current request is, please read the
user's guide. This function can be used in for example the <A
HREF="../../Implementation/HTAlert.html">HTAlert module</A> to give the number of bytes
read in a progress message.

<PRE>
extern long HTRequest_bytesRead(HTRequest * request);
</PRE>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>Using the W3C Reference Library</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen,  4-Dec-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>The Access Manager</H1>

At this point most of the design issues have been addressed and the
Library it is now possible to use the Library to exchange information
between the application an the Internet. The Library provides a set of
functions that can be used to request a URI either on a remote server or
on the local file system. The access method binds the URL with a
specific protocol module as described in section
<A HREF="#access">Access Methods</A> and the stream chains defines the
data flow for incoming and outgoing data.</P>


<H2>Searching a URL</H2>

<B>MORE</B>

<H2>Receiving an Entity</H2>

<B>MORE</B>

<H2>Sending an Entity</H2>

<B>MORE</B>

<H2>Return Codes from the Access manager</H2>

The access manager has a standard set of return codes that the
application can use for diagnostics. They should only be used as
indications of the result as a more detailed description of any error
situation is registered  in the error handler. The set of codes are:</P>

<DL>

<DT><CODE>HT_LOADED</CODE>
<DD>A generic success code that indicates that the request has been
fulfilled

<DT><CODE>HT_NO_DATA</CODE>

<DD>Partly a success code, but no document has been retrieved and a
client application is encouraged to maintain the previous document view
as the current view. A <CODE>HT_NO_DATA</CODE> code might be the result
when a  telnet session is started etc.

<DT><CODE>HT_ERROR</CODE>

<DD>An error has occured and the request could not be fulfilled

<DT><CODE>HT_RETRY</CODE>

<DD>The remote server is temporarily unavailable and no more requests
should be issued to the server before the calendar time indicated in
<CODE>HTRequest-&gt;retry_after</CODE> field. No action is taken by the
Library to automatically retry the request, this is uniquely for the
application to decide. 

<DT><CODE>HT_WOULD_BLOCK</CODE>

<DD>An I/O operation would block and the request must pause. As the
request is not yet terminated, the operation will continue at a later
time when the blocking situation has ceased to exist.

</DL>

<H2>Context Swapping</H2>

In a multithreaded environment it is necessary to keep track of the context of each simultanous
requests issued to the Library as the response might return in another order than the one they were
issued. The Library allows such a context registration in the <A
HREF="../../Implementation/HTReq.html">HTRequest object</A> by providing the registration mechanism
of a call back function and a pointer to an arbitrary data object to be passed to that call back
function. <P>


<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>User Guide - Event Handling</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen,  9-Feb-1996 -->
<NEXTID N="z78">
</HEAD>
<BODY>

<A HREF="../../../"><IMG ALT="W3C" SRC="../../../Icons/WWW/w3c_48x48.gif"></A>
<A HREF="../../"><IMG ALT="Lib" SRC="../../../Icons/WWW/Lib48x.gif"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>The Event Manager</H1>

The W3C Reference Library can be used in either a single-threaded or the multi-threaded programming
style. In this section we will havea look at how to enable this functionality and what the API is
for applications to use it. We will not describe the underlying design model as thsi is described in
detail in the <A HREF="../Architecture/Events.html">Library Architecture</A> documentation.<P>

If you are working on a MSWindows platform then you have the possibility of using asynchronous
socket management (<EM>proactive mode</EM>) instead of typical Unix select based I/O (<EM>reactive
mode</EM>). Please read the <A HREF="../Platform/WinDLL.html">Windows documentation</A> for more
details.

<H2>Event Handlers</H2>

The appplication registers a set of event handlers to be used on a specified set of sockets. An
event handler is a function of type

<PRE>
typedef int HTEventCallback (SOCKET, HTRequest *, SockOps);
</PRE>

<H3>Register a TTY Event Handler</H3>

Register the tty (console) as having events. If the TTY is select()-able (as is true under Unix),
then we treat it as just another socket. Otherwise, take steps depending on the platform. This is
the function to use to register user events!

<PRE>
extern int HTEvent_RegisterTTY	(SOCKET, HTRequest *, SockOps, HTEventCallback *, HTPriority);
</PRE>

<H3>Unregister a TTY Event Handler</H3>

Unregisters TTY I/O channel. If the TTY is select()-able (as is true under Unix), then we treat it
as just another socket.

<PRE>
extern int HTEvent_UnRegisterTTY (SOCKET, SockOps);
</PRE>

<H3>Register an Event Handler</H3>

For a given socket, reqister a request structure, a set of operations, a HTEventCallback function,
and a priority. For this implementation, we allow only a single HTEventCallback function for all
operations.  and the priority field is ignored.

<PRE>
extern int HTEvent_Register	(SOCKET, HTRequest *, SockOps, HTEventCallback *, HTPriority);
</PRE>

<H3>Unregister an Event Handler</H3>

Remove the registered information for the specified socket for the actions specified in ops. if no
actions remain after the unregister, the registered info is deleted, and, if the socket has been
registered for notification, the HTEventCallback will be invoked.

<PRE>
extern int HTEvent_UnRegister	(SOCKET, SockOps);
</PRE>

<H3>Unregister ALL Event Handlers</H3>

Unregister all sockets. N.B. we just remove them for our internal data structures: it is up to the
application to actually close the socket.

<PRE>
extern int HTEvent_UnregisterAll (void);
</PRE>

<H2>Handler for Timeout on Sockets</H2>

This function sets the timeout for sockets in the <CODE>select()</CODE> call and registers a timeout
function that is called if select times out. This does only works on NON windows platforms as we
need to poll for the console on windows If <CODE>tv = NULL</CODE> then timeout is disabled. Default
is no timeout. If <EM>always=YES</EM> then the callback is called at all times, if NO then only when
Library sockets are active. Returns YES if OK else NO.

<PRE>
typedef int HTEventTimeout (HTRequest *);

extern BOOL HTEvent_registerTimeout (struct timeval *tp, HTRequest * request,
				     HTEventTimeout *tcbf, BOOL always);
</PRE>

<H2>Start the Event Loop</H2>

That is, we wait for activity from one of our registered channels, and dispatch on that. Under
Windows/NT, we must treat the console and sockets as distinct.  That means we can't avoid a busy
wait, but we do our best.

<PRE>
extern int HTEvent_Loop (HTRequest * request);
</PRE>

<H2>Stop the Event Loop</H2>

Stops the (select based) event loop. The function does not guarantee that all requests have
terminated. This is for the app to do

<PRE>
extern void HTEvent_stopLoop (void);
</PRE>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML>
<HTML>
<HEAD>
<TITLE>User Guide - Application modules</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 20-Nov-1995 -->
<NEXTID N="z78">
</HEAD>
<BODY>

<A HREF="../../../"><IMG ALT="W3C" SRC="../../../Icons/WWW/w3c_48x48.gif"></A>
<A HREF="../../"><IMG ALT="Lib" SRC="../../../Icons/WWW/Lib48x.gif"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Application modules</H1>

Until now we have described the Library core and the utilities. You might think: "This is all OK,
but how can I get the Library to do something, for example accessing a remote HTTP server?". In the
Library distribution file, you will find many modules that actually can do this and much
more. However, they are not part of the core but of the application. The application can register
the set of modules that provides the desired functionality which is basically what we have seen in
the description of the core. This section discusses the application modules and what functionality
they provide. The Library provides a special include file called <A
HREF="../../Implementation/WWWApp.html">WWWApp.h</A> which includes all the modules mentioned in
this section. This include file <EM>may</EM> be included in an application but is not required. <P>

OK, let's continue and get an overview of the functionality provided by the application modules.

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML>
<HTML>
<HEAD>
<TITLE>Using the W3C Reference Library</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen,  4-Dec-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>The Cache Manager</H2>

Caching is a required part of any efficient Internet access
applications as it saves bandwidth and improves access performance
significantly in almost all types of accesses.  The Library supports
two different types of cache: The memory cache and the file cache. The
two types differ in several ways which reflects their two main
purposes: The memory cache is for short term storage of graphic
objects whereas the file cache is for intermediate term storage of
data objects. Often it is desirable to have both a memory and a file
version of a cached document, so the two types do not exclude each
other. The following paragraphs explains how the two caches can be
maintained in the Library.</P>

<H3><A NAME="memcache">Memory Cache</A></H3>

The memory cache is largely managed by the application as it simply
consists of keeping the graphic objects described by the
<CODE>HyperDoc</CODE> object in memory as the user keeps requesting
new documents. The <CODE>HyperDoc</CODE> object is only declared in
the Library - the real definition is left to the application as it is
for the application to handle graphic objects. The Line Mode Browser
has its own definition of the <CODE>HyperDoc</CODE> object called
<A HREF="../../../LineMode/Implementation/GridText.html"
><CODE>HText</CODE></A>. Before a request is processed over the net,
the anchor object is searched for a <CODE>HyperDoc</CODE> object
and a new request is issued only if this is not present or the Library
explicitly has been asked to reload the document, which is described
in the section <A HREF="#reload">Short Circuiting the Cache</A></P>

As the management of the graphic object is handled by the application,
it is also for the application to handle the garbage collection of the
memory cache. The <A HREF="../../../LineMode/">Line Mode Browser</A>
has a very simple memory management of how long graphic objects stay
around in memory. It is determined by a constant in the <A
HREF="../../../LineMode/Implementation/GridText.c" >GridText</A>
module and is by default set to 5 documents. This approach can be much
more advanced and the memory garbage collection can be determined by
the size of the graphic objects, when they expire etc., but the API is
the same no matter how the garbage collector is implemented. </P>


<H3>File Cache</H3>

The file cache is intended for intermediate term storage of documents
or data objects that can not be represented by the
<CODE>HyperDoc</CODE> object which is referenced by the
<CODE>HTAnchor</CODE> object. As the definition of the
<CODE>HyperDoc</CODE> object is done by the application there is no
explicit rule of what graphic objects that can not be described by the
<CODE>HyperDoc</CODE>, but often it is binary objects, like images
etc.</P>

The file cache in the Library is a very simple implementation in the
sense that no intelligent garbage collection has been defined. It has
been the goal to collect experience from the file cache in the W3C
proxy server before an intelligent garbage collector is implemented in
the Library.  Currently the following functions can be used to control
the cache, which is disabled by default:</P>

<DL>
<DT><CODE>HTCache_enable()</CODE>, <CODE>HTCache_disable()</CODE>, and
<CODE>HTCache_isEnabled()</CODE>
<DD>Use these functions to enable and disable the cache

<DT><CODE>HTCache_setRoot()</CODE> and <CODE>HTCache_getRoot()</CODE>
<DD>Use these functions to set and get the value of the cache root
</DL>

An important difference between the memory cache and the file cache is
the format of the data. In the memory cache, the cached objects are
graphic objects ready to be displayed to the user. In the file cache
the data objects are stored along with their metainformation so that
important header information like Expires, Last-Modified, Language
etc.  is a part of the stored object.</P>

<H3><A NAME="reload">Mode for Cache Refresh</A></H3>

In situations where a cached document is known to be stale it is
desired to flush any existent version of a document in either the
memory cache or the file cache and perform a reload from the
authoritative server. This can for example be the case if an expires
header has been defined for the document when returned from the origin
server. Forcing a refresh from either the memory cache, the file
cache, or both can be done using the following function:

<PRE>
void HTRequest_setReload (HTRequest *request, HTReload mode);
HTReload HTRequest_reload (HTRequest *request);
</PRE>

where <CODE>HTReload</CODE> can be either of the values

<DL>
<DT>HT_ANY_VERSION
<DD>Use any version available, either from memory cache or from local
file cache

<DT>HT_MEM_REFRESH

<DD><EM>Non-authoritative</EM> update of any version stored in
memory. The new version can either come from the local file cache, a
proxy cache or the network. If the request falls through to the
network, the Library issues a conditional GET using a
<EM>If-Modified-Since</EM> header. There are two main purposes for
this mode:

<OL>
<LI>If the disk cache is private to exactly one application then a
version stored in the local disk cache does normally not differ in
time from a version in memory - they have been created at the same
time. However, in a shared cache environment, the two versions can
differ and this flag can be used to force an update to the latest
version in the file cache.
<LI>If the application wants to see the metainformation as received
from the network, then the object in the file cache provides this
information whereas the version in memory does not.
</OL>

<DT>HT_CACHE_REFRESH

<DD><EM>Authoritative</EM> update of any version stored in the local
file cache or a proxy cache. The Library issues a conditional GET
using a <EM>If-Modified-Since</EM> header and a <EM>Pragma:
no-cache</EM> to ensure that the response is authoritative.

<DT>HT_FORCE_RELOAD

<DD>Unconditinal reload from the network using the <EM>Pragma:
no-proxy</EM> directive in order to insure that the reload is passed
to any proxy server on the way to the origin server

</DL>

If the Library receives either an authoritative or non-authoritative
"304 Not Modified" response upon any of the requests above, it 

<H3>Handling Expired Documents</H3>

There are various ways of handling Expires header when met in a
history list. Either it can be ignored all together, the user can be
notified with a warning, or the document can be reloaded
automatically. The Libarry supports either way, as it should be up to
the user to decide. The default action is HT_EXPIRES_IGNORE, but other
modes are to notify the user that a document is stale without
reloading it, and to do an automatic relaod of the document. Th
functions to use are in this case:

<PRE>
void HTAccess_setExpiresMode (HTExpiresMode mode, char *  notify);
HTExpiresMode HTAccess_expiresMode ();
</PRE>

where <CODE>HTExpiresMode</CODE> can take any of the values:

<PRE>
    HT_EXPIRES_IGNORE
    HT_EXPIRES_NOTIFY
    HT_EXPIRES_AUTO
</PRE>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>User's Guide - Proxies and Gateways</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 29-Jan-1996 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Registering Proxy Servers and Gateways</H1>

Applications do not have to provide native support for all protocols, they can in many situations
rely on the support of proxies and gateways to help doing the job. Proxy servers are often used to
carry client requests through a firewall where they can provide services like corporate caching and
other network optimizations. Both Proxy servers and gateways can serve as "protocol translators"
which can convert a request in the main Web protocol, HTTP, to an equivalent request in another
protocol, for example NNTP, FTP, or Gopher. In case a proxy server or a gateway is available to the
application, it can therefore by use of HTTP forward all requests to for example a proxy server
which then handle the communications with the remote server, for example using FTP about the
document and return it to the application (proxy client) using HTTP. <P>

The Library supports both proxies and gateways through the <A
HREF="../../Implementation/HTProxy.html">HTProxy module</A> and all requests can be redirected to a
proxy or a gateway, even requests on the local file system. Of course, the Library can also be used
in proxy or gateway applications which in terms can use other proxies or gateways so that a single
request can be passed through a series of intermediate agents.<P>

There is one main mechanism for registering both proxies and gateways but there are two different
APIs to follow. It is free to the application to chose which one suits it the best, the
functionality provided by the Library is the same in both cases. The first API is based on a set of
registration functions as we have seen it so often through out this guide. Regardless of the
registration mechanism used, proxy servers are always rated higher than gateways so if both a proxy
server and a gateway is registered for the same access method, the proxy server will be used.<P>

<H2>Registration of Proxies</H2>

A proxy server is registered with a corresponding access method, for example <EM>http</EM>,
<EM>ftp</EM> etc. The `proxy' parameter should be a fully valid name, like
<CODE>http://proxy.w3.org:8001</CODE> but domain name is not required. If an entry exists for this
access then delete it and use the new one.

<PRE>
extern BOOL HTProxy_add		(CONST char * access, CONST char * proxy);
</PRE>

In addition to the proxy list, the Library supports a list of servers for which a proxy should
<EM>not</EM> be consulted. This can be useful in order to avoid going via a proxy server for servers
inside a firewall, if the server is known to be either as well connected as the proxy or the remote
server is in fact itself a proxy server.

<PRE>
extern BOOL HTNoProxy_add	(CONST char * host, CONST char * access, unsigned port);
</PRE>

The set of server registered using this function are host names and domain names where we don't
contact a proxy even though a proxy is in fact registered for this particular access method. When
registering a server as a <EM>noproxy</EM> element, you can specify a specific port for this access
method in which case it is valid only for requests to this port. If `port' is '0' then it applies to
all ports and if `access' is NULL then it applies to to all access methods. Examples of host names
are:

<PRE>
	w3.org
	www.fastlink.com
</PRE>

<H2>Registration of Gateways</H2>

Gateways are registered exactly like proxy servers: it is registered with a corresponding access
method, for example <EM>http</EM>, <EM>ftp</EM> etc. The `gate' parameter should be a fully valid
name, like <CODE>http://gateway.w3.org:8001</CODE> but domain name is not required. If an entry
exists for this access then delete it and use the new one.

<PRE>
extern BOOL HTGateway_add	(CONST char * access, CONST char * gate);
</PRE>

<H2>Backwards Compatibility with Environment Variables</H2>

Proxy servers and gateways have historically been registered environment variables which is a
Unix'ism and not especially portable. However, in order to support this way of registration, the
Library provides the following function to read the environment variables that defines proxy severs
and gateways.

<PRE>
extern void HTProxy_getEnvVar	(void);
</PRE>

There is no standard for the format of the environment variables, but the most accepted convention
is the format described here:

<DL>

<DT><CODE>WWW_&lt;access&gt;_GATEWAY</CODE>

<DD>Definition of a gateway. Note that a WAIS gateway can be defined this way to change the default
gateway at <A HREF="wais://www.w3.org:8001/">wais://www.w3.org:8001/</A>.

<DT><CODE>&lt;access&gt;_proxy</CODE>

<DD>Definition of a proxy server

<DT><CODE>no_proxy</CODE>

<DD>This is a comma separated list of remote servers where a proxy server should <EM>not</EM> be
consulted for handling the request. An example is

<PRE>
	no_proxy="cern.ch,ncsa.uiuc.edu,some.host:8080"
	export no_proxy
</PRE>

</DL>

<CODE>&lt;access&gt;</CODE> is the specific access scheme and it is case sensitive as access schemes
in URIs are case sensitive. Proxy servers have precedence over gateways, so if both a proxy server
and a gateway has been defined for a specific access scheme, the proxy server is selected to handle
the request.<P>

It is important to note that the usage of proxy servers or gateways is an extension to the binding
between an access scheme and a protocol module. An application can be set up to redirect all URLs
with a specific access scheme without knowing about the semantics of this access scheme or how to
access the information directly. That way, powerful client applications can be built having direct
support for, for example, HTTP only.

<H2>Finding Proxies and Gateways</H2>

Registering a proxy server or a gateway does not mean that the request automatically is redirected
to the new location instead of the origin server. In order to actually redirect a request, you can
register a <A HREF="Net.html#pre">Pre-Request Callback function</A> which will bet called before a
request is actually sent over the wire. You can find more information on how to actually redirect a
request to for example a proxy server in the section <A HREF="Net.html#proxying">Proxies and
Gateways</A>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>User Guide - Rule Files</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 21-Nov-1995 -->
<NEXTID N="z78">
</HEAD>
<BODY>

<A HREF="../../../"><IMG ALT="W3C" SRC="../../../Icons/WWW/w3c_48x48.gif"></A>
<A HREF="../../"><IMG ALT="Lib" SRC="../../../Icons/WWW/Lib48x.gif"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Rule Files</H1>

The W3C Library provides this module for handling configuration files (a.k.a.  rule files). Rule
files can be used to initialize as much as the application desires including setting up new protocol
modules etc. Also the rules file do not have to be a file - it can be a database or any other way of
storage information. This implementation is not used by the Library at all and is part of the <A
HREF="../../Implementation/WWWApp.html">WWWApp.h</A> interface. <P>

Parsing a whole rule file is done using a converter stream. This means that a rule file can come
from anywhere, even across the network. We have defined a special content type for rule files
called <CODE>WWW_RULES</CODE> in <A HREF="../../Implementation/HTFormat.html">HTFormat</A>. <P>

In some situations, a set of rules comes from a subset of a file or some other origin, for example
INI files for X resources. In that case, you can also parse a single line from a rules file using
the following function:

<PRE>
extern BOOL HTRule_parseLine (HTList * list, CONST char * config);
</PRE>

You can add a rule to a list of rules as any other preference. The <CODE>pattern</CODE> is a string
containing a single "*". <CODE>replace</CODE> points to the equivalent string with * for the place
where the text matched by * goes.

<PRE>
typedef enum _HTRuleOp {
    HT_Invalid, 
    HT_Map, 
    HT_Pass, 
    HT_Fail,
    HT_DefProt,
    HT_Protect,
    HT_Exec,
    HT_Redirect,
    HT_UseProxy
} HTRuleOp;

extern BOOL HTRule_add (HTList * list, HTRuleOp op, CONST char * pattern, CONST char * replace);
</PRE>

And as normal you can delete a set of rules by using this function:

<PRE>
extern BOOL HTRule_deleteAll (HTList *list);
</PRE>

<H2>Global Rules</H2>

Rules are handled as list as everything else that has to do with preferences. We provide two
functions for getting and setting the global rules:

<PRE>
extern HTList * HTRule_global	(void);
extern BOOL HTRule_setGlobal	(HTList * list);
</PRE>

<H2>Translate by rules</H2>

This function walks through the list of rules and translates the reference when matches are
found. The list is traversed in order starting from the head of the list. It returns the address of
the equivalent string allocated from the heap which the CALLER MUST FREE. If no translation occured,
then it is a copy of the original.

<PRE>
extern char * HTRule_translate (HTList * list, CONST char * token, BOOL ignore_case);
</PRE>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML>
<HTML>
<HEAD>
<TITLE>Using the W3C Reference Library</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 23-Aug-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>The Log Module</H1>

It is possible to log the result of a request to the Library whether
regardless of what type of application is using the Library. The
current implementation of the log manager is very simple but it is
straight forward to replace the implementation with a more
sofisticated one. The current log format is defined as follows:

<PRE>
	&lt;HOST&gt; &lt;DATE&gt; &lt;METHOD&gt; &lt;URI&gt; &lt;RESULT&gt; &lt;CONTENT LENGTH&gt;
</PRE>

where the date and time stamp can be either in local time or
GMT. Logging is turned off but the application can enable it at any
time. However, it is also for the application to disable the logging
in order to close any open file descriptors etc. The exact log API is
described in the <A HREF="../../Implementation/HTLog.html">Log
Manager</A>.

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>Using the W3C Reference Library</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen,  4-Dec-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Keeping Track of History</H1>

The Library supports client applications in keeping track of which
locations the user has visited while browsing the Web. The internal
history list is implemented in the <A
HREF="../../Implementation/HTHist.html">HTHist module</A>. This module
is completely autonomous as it is not used by any other modules in the
Library so if it is not referred to in the application code then it
will not be linked into the linked application. This means that if the
application does not need recording of history then no action is
required at all.<P>

The purpose of the history module is to try not to impose any
particular history mechanism policy but instead to allow various
different history mechanisms. The basic features of the history module
are:

<UL>
<LI>The module can handle multiple history lists
<LI>The underlying data model is linear lists
<LI>The module keeps a position pointer into this list
<LI>The application can refer to an element in the list by an index
</UL>

Some of the navigation steps supported by the module are "back",
"forward", and jump to a position in the list. The details of the
module is listed in the declaration part of the <A
HREF="../../Implementation/HTHist.html">HTHist module</A>.

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>Using the W3C Reference Library</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 27-Aug-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Presentation Modules</H1>

The HTML parser has three different levels of APIs in order to make
the implementation as flexible as possible.  Depending on which API is
used by the application, the output can be a stream, a structured stream
or a set of callback functions as indicated in the figure below:

<P><IMG SRC="../Guide/Interfaces.gif" ALT="HTMLParser"><P>

<DL>

<DT>SGML Stream Interface

<DD>This interface provides the most basic API consisting of the
output from a stream without any form for structure imposed on the
data. The internal <A HREF="../../Implementation/SGML.html">SGML
parser</A> parses the data sequence, identifies SGML markup tags, and
passes the information on the the <A
HREF="../../Implementation/HTML.html">HTML parser</A>. However, if the
application has its own SGML parser and HTML parser, the internal
parsers can be disabled by removing the internal HTML converter called
<CODE>HTMLPresent()</CODE> used to present a graphic object on the
screen from both the global and the local list of converters and
presenters.

<DT>HTML Structured Stream Interface

<DD>If the application has its own HTML parser that understands the
structured output from the internal SGML parser then the second API
can be used. The current HTML parser in the Library is very basic and
does not understand many of the new features in HTML 2 and 3.

<DT>HText Call Back Interface

<DD>The last API can be in case the application prefers to use the
internal HTML parser and only wants to provide a platform dependent
definition of the callback functions defined in the <A
HREF="../../Implementation/HText.html" >HText module</A>.  Now, the
parsing is all done internally in the Library and the application is
only called with segments of fully parsed HTML. The callback functions
are all defined as prototypes in the <A
HREF="../../Implementation/HText.html" >HText module</A> but the
client must provide the actual code that defines the presentation
method used for a specific HTML tag.

</DL>

Due to the limited functionality of the internal HTML parsing module,
many applications have chosen to implement their own HTML
parser. Therefore many regard the HTML parser module as being an
<EM>application specific module</EM> instead of a <EM>dynamic
module</EM>. This will be alleviated in the next version of the
Library, which hopefully will ease the use of the internal HTML
parser. The current parser can be overriding as described in section
<A HREF="#override">Application Specific Modules</A>.

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>User Guide - The Library Utilities</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 20-Nov-1995 -->
<NEXTID N="z78">
</HEAD>
<BODY>

<A HREF="../../../"><IMG ALT="W3C" SRC="../../../Icons/WWW/w3c_48x48.gif"></A>
<A HREF="../../"><IMG ALT="Lib" SRC="../../../Icons/WWW/Lib48x.gif"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>The Library Utilities</H1>

The Library contains a set of basic utility modules which are used throughour all the Library
code. The APIs defined by the <A HREF="../../Implementation/WWWUtil.html">WWWUtil.h</A> include file
provides basic memory management and container modules. You can see a list of the utility modules in
the <A HREF="../Guide/Utils.html">Library Internals</A>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML>
<HTML>
<HEAD>
<TITLE>Using - Dynamic Memory management</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 17-Jan-1996 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Dynamic Memory Management</H1>

The Library makes use of a dynamic memory manager which handles allocation and deallocation of
dynamic memory. The methods used for allocation and deallocation are wrapper functions around the
native <CODE>malloc</CODE>, <CODE>calloc</CODE>, <CODE>realloc</CODE>, and <CODE>free</CODE>
methods. Hence, the functionality of teh module is very similar to the native C interface but it
allows for structured error recovery and application termination in case of failure.  It covers
especially the following three situations:

<UL>
<LI>Handling of allocation and deallocation of dynamic memory
<LI>Recovering from temporary lack of available memory
<LI>Panic handling in case a new allocation fails
</UL>

<H2>Memory Freer Functions</H2>

The dynamic memory freer functions are typically functions that are capable of freeing large chunks
of memory. In case a new allocation fails, the allocation method looks for any freer functions to
call. There can be multriple freer functions and after each call, the allocation method tries again
to allocate the desired amount of dynamic memory. The freer functions are called in <EM>reverse</EM>
order meaning that the <EM>last</EM> one registered gets called <EM>first</EM>. That way, it is easy
to add temporary free functions which then are guaranteed to be called first if a methods fails.

<H3>Add a Freer Function</H3>

You can add a freer function by using the following method. The Library itself registeres a set of
free functions during initialization. If the application does not register any freer functions then
the Library looks how it can free internal memory.

<PRE>
typedef void HTMemoryCallback(size_t size);

extern BOOL HTMemoryCall_add (HTMemoryCallback * cbf);
</PRE>

<H3>Delete a Freer Function</H3>

Freer functions can be deleted at any time in which case they are not called anymore.

<PRE>
extern BOOL HTMemoryCall_delete (HTMemoryCallback * cbf);
extern BOOL HTMemoryCall_deleteAll (void);
</PRE>

<H2>Panic Handling</H2>

If the freer functions are not capable of deallocation enough memory then the application must have
an organized way of closing down. This is done using the panic handler. In the libwww, each
allocation is tested and HT_OUTOFMEM is called if a NULL was returned. HT_OUTOFMEM is a macro which
calls HTMemory_outofmem. This function calls an exit function defined by the app in a call to
HTMemory_setExit. If the app has not defined this function, HTMemory_outofmem TTYPrints the error
message and calls exit(1).

<PRE>
typedef void HTMemoryExitCallback(char * name, char * file, unsigned long line);

extern void HTMemory_setExit(HTMemoryExitCallback * pExit);

extern HTMemoryExitCallback * HTMemory_exit(void);
</PRE>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
<HTML>
<HEAD>
<TITLE>Using - Global Flags</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 15-Nov-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/w3c_48x48.gif" ALT="W3C"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A>

<H1>Trace Messages and Preprocessor Defines</H1>

The Library has a huge amount of trace messages that are very useful when debugging an application.
In this section we will have a look at how to use the trace messages and also what preprocessor
defines that can be used to modify the behavior of the Library.

<H2>Trace Messages</H3>

The Library has a huge set of trace messages that can be enabled in various ways. They are often an
important help to the application programmer in order to debug an application and this is the reason
why they are trated in this User's Guide. <P>

<B>MORE</B>

<H2>Preprocessor Defines</H2>

Most of the preprocessor defines in the Library are platform dependent that are determined as a
result of the <EM>BUILD script</EM>. However, there are some few defines that on a platform
independent basis can change the default behavior of the Library.</P>

<DL>
<DT><CODE>HT_REENTRANT</CODE>
<DD>This boolean define should be enabled if the reentrant versions ("*_r") of the system calls
should be used. The name of these system calls are currently "*_r", for example
<CODE>strtok_r</CODE>. The default value is <EM>OFF</EM>.

<DT><CODE>HT_SHARED_DISK_CACHE</CODE>
<DD>If the cache can be shared between several clients this will have an effect on the way, update
of a document will be done. The default cache implementation of the cache manager does not support
this so the default value is NOT defined.

<DT><CODE>HT_DIRECT_WAIS</CODE>
<DD>This boolean define is enabled by the <EM>Makefile.include</EM> file as described in section <A
HREF="Methods.html">Access Methods</A>. The default value is <EM>OFF</EM>.

<DT><CODE>HT_DEFAULT_WAIS_GATEWAY</CODE>
<DD>A constant string value which WAIS gateway to contact if
<CODE>HT_DIRECT_WAIS</CODE> is not defined and no gateway has been
defined using environment variables

<DT><CODE>HT_FTP_NO_PORT</CODE>
<DD>The FTP module can handle both <CODE>PASV</CODE> and <CODE>PORT</CODE> when requesting a
document from a FTP server. If the application is a proxy server running on top of a firewall
machine then <CODE>PORT</CODE> is normally not allowed as a firewall does not accept incoming
connections on arbitrary ports. This define will disable the use of <CODE>PORT</CODE>. The default
value is to <EM>use</EM> <CODE>PORT</CODE> if <CODE>PASV</CODE> fails.

<DT><CODE>WWWLIB_SIG</CODE>
<DD>The Library has a very small set of signal handlers whose action most often are simply to ignore
the signals. However, due to a bug in the TCP kernel on Solaris and other SVR4 platforms returning a
SIG_PIPE signal, some kind of handling is required on these platforms, and the signal handling is
enabled by default on these platforms.

<DT><CODE>HT_TMP_ROOT</CODE>
<DD>The default destination for temporary files if no other destination has been given by the
application. Temporary files include files created for external presenters etc. The default value is
<CODE>/tmp</CODE> which obviously is not suited for large amount of data.

<DT><CODE>HT_CACHE_ROOT</CODE>
<DD>If the cache is enabled and no cache root directory has been specified then use this as the
location. The default value is again <CODE>/tmp</CODE>.

<DT><CODE>HT_NO_RULES</CODE>
<DD>If this flag is enabled then no configuration or rule file is searched for map rules when
handling a request even if a rule file has been specified by the application. The default value is
<EM>OFF</EM>

<DT><CODE>HT_NO_PROXY</CODE>
<DD>If no environment variables are to be searched for gateways or proxies for a request. The
default value is <EM>OFF</EM>

</DL>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, December 1995</ADDRESS>
</BODY>
</HTML> 
